<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>西瓜书+南瓜书——（三）线性模型</title>
      <link href="/2025/08/20/%E8%A5%BF%E7%93%9C%E4%B9%A6+%E5%8D%97%E7%93%9C%E4%B9%A6%E5%AD%A6%E4%B9%A0/%E4%B8%89_%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/"/>
      <url>/2025/08/20/%E8%A5%BF%E7%93%9C%E4%B9%A6+%E5%8D%97%E7%93%9C%E4%B9%A6%E5%AD%A6%E4%B9%A0/%E4%B8%89_%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="西瓜书-南瓜书——（三）线性模型"><a href="#西瓜书-南瓜书——（三）线性模型" class="headerlink" title="西瓜书+南瓜书——（三）线性模型"></a>西瓜书+南瓜书——（三）线性模型</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本次笔记为<code>DataWhale周志华机器学习入门</code>课程相关记录</p><p>引用资料：[1]. <a href="https://www.datawhale.cn/learn/summary/2">https://www.datawhale.cn/learn/summary/2</a><br>                   [2]. 周志华. 机器学习[M]. 北京: 清华大学出版社, 2016.</p><h2 id="3-1-基本形式"><a href="#3-1-基本形式" class="headerlink" title="3.1 基本形式"></a>3.1 基本形式</h2><ul><li>给定由$d$个属性描述的示例$\pmb{x}&#x3D;(x_1;x_2;…;x_d)$，其中$x_i$是$\pmb{x}$在第$i$个属性上的取值，线性模型通过属性的线性组合来进行预测</li></ul><p>$$<br>f(\pmb{x})&#x3D;w_1x_1+w_2x_2+…+w_dx_d+b\<br>向量形式：f(\pmb{x})&#x3D;\pmb{w^T}\pmb{x}+b<br>$$</p><p>其中$\pmb{w}&#x3D;(w_1;w_2;…;w_d)$。$\pmb{w}$和$b$学得之后，模型就确定了</p><ul><li>线性模型<strong>形式简单、易于建模</strong></li></ul><h2 id="3-2-线性回归"><a href="#3-2-线性回归" class="headerlink" title="3.2 线性回归"></a>3.2 线性回归</h2><ul><li>给定数据集$D&#x3D;{(\pmb{x_1},y_1),(\pmb{x_2},y_2),…,(\pmb{x_m},y_m)}$，其中$\pmb{x_i}&#x3D;(x_{i1};x_{i2};…;x_{id};),y_i\in \mathbb{R}$</li><li>对离散属性，若属性值间存在“序“关系，可通过连续化将其转化为连续值</li><li>最简单情形为例，输入属性的数目只有一个。线性回归试图学得</li></ul><p>$$<br>f(x_i)&#x3D;wx_i+b,使得f(x_i) \simeq y_i<br>$$</p><p>均方误差是回归任务中最常用的性能度量，有着良好的几何意义，对应了常用的欧几里得距离。基于均方误差最小化来进行模型求解的方法称为“最小二乘法”。在线性回归中，最小二乘法就是试图找到一条直线，是所有样本到直线上的欧式距离之和最小。</p><p>可得$w$和$b$最优解的闭式解<br>$$<br>w &#x3D; \frac{\sum_{i&#x3D;1}^{m} y_i \left(x_i - \bar{x}\right)}<br>         {\sum_{i&#x3D;1}^{m} x_i^2 - \frac{1}{m}\left(\sum_{i&#x3D;1}^{m} x_i\right)^2} \<br>b &#x3D; \frac{1}{m} \sum_{i&#x3D;1}^{m} \left( y_i - w x_i \right)<br>$$<br>其中$\bar{x} &#x3D; \frac{1}{m}\sum_{i &#x3D; 1}^{m}x_{i}$为$x$的均值</p><ul><li>数据集$D$中的样本由$d$个属性描述，此时为”多元线性回归“</li></ul><p>线性回归模型为$f(\hat{x}_i) &#x3D; \hat{x}_i^{\text{T}} (\mathbf{X}^{\text{T}} \mathbf{X})^{-1} \mathbf{X}^{\text{T}} \mathbf{y}$。现实任务中$\mathbf{X}^\text{T}\mathbf{X}$往往不是满秩矩阵，选择哪一个解作为输出，由学习算法的归纳偏好决定，常见做法是引入正则化项</p><ul><li>模型预测值逼近$y$的衍生物</li></ul><p>$$<br>\ln y &#x3D; \boldsymbol{w}^{\text{T}} \boldsymbol{x} + b<br>$$</p><p>所谓的“对数线性回归”。它实际上是在试图让 $e^{\boldsymbol{w}^{\text{T}}\boldsymbol{x} + b}$ 逼近 $y$。形式上仍是线性回归, 但实质上已是在求取输入空间到输出空间的非线性函数映射</p><ul><li><strong>广义线性模型：</strong>$y &#x3D; g^{-1}(\boldsymbol{w}^{\text{T}}\boldsymbol{x} + b)$，其中函数$g(\cdot)$称为“联系函数”，单调可微。对数线性回归是广义线性模型在 $g(\cdot) &#x3D; \ln(\cdot)$时的特例</li></ul><h2 id="3-3-对数几率回归"><a href="#3-3-对数几率回归" class="headerlink" title="3.3 对数几率回归"></a>3.3 对数几率回归</h2><p>**做分类问题应该如何？**找一个单调可微函数将分类任务的真实标记$y$与线性回归模型的预测值联系起来</p><p>考虑二分类任务的话，输出标记$y \in {0,1}$。线性回归模型预测值为$z &#x3D; \boldsymbol{w}^\text{T}\boldsymbol{x} + b$是实值，转化为0&#x2F;1值，可用单位阶跃函数$y &#x3D; \begin{cases}  0, &amp; z &lt; 0; \  0.5, &amp; z &#x3D; 0; \  1, &amp; z &gt; 0,  \end{cases}$</p><ul><li>单位阶跃函数不连续，不能作为 $g^-(·)$，近似单位阶跃函数——对数几率函数</li></ul><p>$$<br>y&#x3D;\frac{1}{1+e^{-z}}<br>$$</p><p>代入$z$，有<br>$$<br>y&#x3D;\frac{1}{1+e^{-(\boldsymbol{w}^\text{T}\boldsymbol{x} + b)}}<br>$$<br>两边取对数，可化为<br>$$<br>\ln \frac{y}{1 - y} &#x3D; \boldsymbol{w}^{\text{T}}\boldsymbol{x} + b<br>$$<br>若将$y$视为样本$\boldsymbol{x}$作为正例的可能性，则$1-y$是其反例可能性，两者的比值$\frac{y}{1-y}$称为**“几率”<strong>，反映了$\boldsymbol{x}$作为正例的相对可能性。$\ln \frac{y}{1 - y}$即为</strong>“对数几率”**</p><p><strong>实际上是在用线性回归模型的预测结果去逼近真实标记的对数几率</strong></p><ul><li>将$y$视为后验概率估计$p(y &#x3D; 1 \mid \boldsymbol{x})$，则有</li></ul><p>$$<br>\ln\frac{p(y &#x3D; 1|\boldsymbol{x})}{p(y &#x3D; 0|\boldsymbol{x})} &#x3D; \boldsymbol{w}^{\text{T}}\boldsymbol{x} + b<br>$$</p><ul><li><p>$$<br>p(y &#x3D; 1 \mid \boldsymbol{x}) &#x3D; \frac{e^{\boldsymbol{w}^T\boldsymbol{x} + b}}{1 + e^{\boldsymbol{w}^T\boldsymbol{x} + b}} \<br>p(y &#x3D; 0 \mid \boldsymbol{x}) &#x3D; \frac{1}{1 + e^{\boldsymbol{w}^T\boldsymbol{x} + b}}<br>$$</p></li><li><p>可通过“极大似然法”来估计$ \boldsymbol{w}$和$b$</p></li></ul><p>$$<br>\ell(\boldsymbol{w},b)&#x3D;\sum_{i &#x3D; 1}^{m}\ln p(y_{i}\mid\boldsymbol{x}_{i};\boldsymbol{w},b)<br>$$</p><ul><li>令$ \boldsymbol{\beta}&#x3D;(\boldsymbol{w};b)$，$\hat{\boldsymbol{x}} &#x3D; (\boldsymbol{x}; 1)$，则似然项可重写为</li></ul><p>$$<br>p(y_i \mid \boldsymbol{x}_i; \boldsymbol{w}, b) &#x3D; y_i p_1(\hat{\boldsymbol{x}}_i; \boldsymbol{\beta}) + (1 - y_i) p_0(\hat{\boldsymbol{x}}<em>i; \boldsymbol{\beta})<br>\<br>\ell(\boldsymbol{\beta}) &#x3D; \sum</em>{i&#x3D;1}^{m} \left( -y_i \boldsymbol{\beta}^\mathrm{T} \hat{\boldsymbol{x}}_i + \ln\left(1 + e^{\boldsymbol{\beta}^\mathrm{T} \hat{\boldsymbol{x}}_i}\right) \right)<br>$$</p><ul><li>上式是关于$\boldsymbol{\beta}$的高阶导连续凸函数，由凸优化理论，经典的数值优化算法可以求得最优解——梯度下降法、牛顿法等</li></ul><p>$$<br>\boldsymbol{\beta}^* &#x3D; \arg\min_{\boldsymbol{\beta}} \ell(\boldsymbol{\beta})<br>$$</p><ul><li>梯度下降法和牛顿法本质都是迭代逼近函数极值。不同在于：梯度下降仅用一阶导数（梯度）确定更新方向，计算简单，但收敛速度较慢；牛顿法同时利用一、二阶导数，通过构建海森矩阵逆来优化方向，收敛更快，不过计算复杂度更高</li></ul><h2 id="3-4-线性判别分析"><a href="#3-4-线性判别分析" class="headerlink" title="3.4 线性判别分析"></a>3.4 线性判别分析</h2>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 西瓜书 </tag>
            
            <tag> 南瓜书 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>西瓜书+南瓜书——（二）模型评估与选择</title>
      <link href="/2025/08/19/%E8%A5%BF%E7%93%9C%E4%B9%A6+%E5%8D%97%E7%93%9C%E4%B9%A6%E5%AD%A6%E4%B9%A0/%E4%BA%8C_%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/"/>
      <url>/2025/08/19/%E8%A5%BF%E7%93%9C%E4%B9%A6+%E5%8D%97%E7%93%9C%E4%B9%A6%E5%AD%A6%E4%B9%A0/%E4%BA%8C_%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="西瓜书-南瓜书——（二）模型评估与选择"><a href="#西瓜书-南瓜书——（二）模型评估与选择" class="headerlink" title="西瓜书+南瓜书——（二）模型评估与选择"></a>西瓜书+南瓜书——（二）模型评估与选择</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本次笔记为<code>DataWhale周志华机器学习入门</code>课程相关记录</p><p>引用资料：[1]. <a href="https://www.datawhale.cn/learn/summary/2">https://www.datawhale.cn/learn/summary/2</a><br>                   [2]. 周志华. 机器学习[M]. 北京: 清华大学出版社, 2016.</p><h2 id="2-1-经验误差与过拟合"><a href="#2-1-经验误差与过拟合" class="headerlink" title="2.1 经验误差与过拟合"></a>2.1 经验误差与过拟合</h2><p><code>错误率</code>：分类错误的样本数占样本总数的比例</p><p><code>精度</code>：<code>1-错误率</code></p><p><code>训练误差</code>：模型在训练集上的误差</p><p><code>泛华误差</code>：模型在新样本上的误差</p><p><strong>我们希望的是，在新样本上能表现得很好的学习器</strong></p><ul><li><strong>过拟合</strong>：训练样本学的“太好”，泛化性能下降</li><li><strong>欠拟合</strong>：训练样本学的“不好”</li></ul><p><code>欠拟合比较容易克服，过拟合无法彻底避免，只能缓解</code></p><h2 id="2-2-评估方法"><a href="#2-2-评估方法" class="headerlink" title="2.2 评估方法"></a>2.2 评估方法</h2><p>利用“测试集”来测试模型对新样本的判别能力，以“测试误差”作为泛化误差的近似</p><p><strong>测试集尽可能与训练集互斥</strong>，从数据集中产生训练集<code>S</code>和测试集<code>T</code></p><h3 id="2-2-1-留出法"><a href="#2-2-1-留出法" class="headerlink" title="2.2.1 留出法"></a>2.2.1 留出法</h3><ul><li>将数据集<code>D</code>划分为两个互斥的结合，其中一个集合作为训练集<code>S</code>，另一个作为测试集<code>T</code>，即$D&#x3D;S \cup T,S \cap T &#x3D; \emptyset$，在<code>S</code>上训练出模型后，用<code>T</code>来评估其测试误差，作为对泛化误差的估计</li><li>训练集和测试集的比例问题没有完美的解决方案，常见做法是将大约2&#x2F;3-4&#x2F;5的样本用于训练，剩余样本用于测试</li><li>给定划分比例后，也存在多种划分方式进行数据集<code>D</code>分割，多次划分方式测试</li></ul><h3 id="2-2-2-交叉验证法"><a href="#2-2-2-交叉验证法" class="headerlink" title="2.2.2 交叉验证法"></a>2.2.2 交叉验证法</h3><ul><li><p>将数据集<code>D</code>划分为<code>k</code>个大小相似的互斥子集，即$D&#x3D;D_1 \cup D_2 \cup … \cup D_k,D_i \cap D_j &#x3D; \emptyset (i \neq j)$。每个子集$D_i$都尽可能保持数据分布的一致性，即从<code>D</code>中通过分层采样得到</p></li><li><p>每次用<code>k-1</code>个子集的并集作为训练集，余下那个子集作为测试集，这样获得<code>k</code>组训练&#x2F;测试集，进行<code>k</code>次训练和测试，返回<code>k</code>个测试结果的平均值</p></li><li><p><code>k</code>常用10，称为10折交叉验证</p></li><li><p>同留出法，不同划分多次，如p次k折交叉验证，常见的用“10次10折交叉验证”</p></li><li><p><code>D</code>中有<code>m</code>个样本，若令<code>k=m</code>，则得到交叉验证法的一个特例：留一法，唯一划分，大规模样本复杂度高</p></li></ul><h3 id="2-2-3-自助法"><a href="#2-2-3-自助法" class="headerlink" title="2.2.3 自助法"></a>2.2.3 自助法</h3><ul><li><code>m</code>个样本数据集<code>D</code>，对其进行采样得到数据集<code>D&#39;</code>：<code>m</code>次可重复采样得到<code>D&#39;</code>。样本在<code>m</code>次采样中始终不被采到的概率为$(1-\frac{1}{m})^m$，取极限可得该式为<code>0.368</code>，即数据集<code>D</code>中约有<code>36.8%</code>的样本未出现在采样数据集<code>D&#39;</code>中</li><li><code>D&#39;</code>用作训练集，<code>D\D&#39;</code>用作测试集，实际评估的模型与期望评估的模型都使用<code>m</code>个训练样本</li><li>在数据集较小、难以有效划分训练&#x2F;测试集时很有用</li></ul><h3 id="2-2-4-调参与最终模型"><a href="#2-2-4-调参与最终模型" class="headerlink" title="2.2.4 调参与最终模型"></a>2.2.4 调参与最终模型</h3><ul><li>训练数据划分为<strong>训练集和验证集</strong>，基于验证集上的性能来进行模型选择和调参</li><li><strong>测试集</strong>估计模型在实际使用时的泛化能力</li></ul><h2 id="2-3-性能度量"><a href="#2-3-性能度量" class="headerlink" title="2.3 性能度量"></a>2.3 性能度量</h2><p><strong>对模型的泛化能力进行评估，需要有衡量模型泛化能力的评价标准，这就是性能度量</strong></p><h3 id="2-3-1-错误率与精度"><a href="#2-3-1-错误率与精度" class="headerlink" title="2.3.1 错误率与精度"></a>2.3.1 错误率与精度</h3><ul><li><strong>错误率</strong>：分类错误的样本数占样本总数的比例</li><li><strong>精度</strong>：分类正确的样本数占样本总数的比例</li></ul><h3 id="2-3-2-查准率、查全率与F1"><a href="#2-3-2-查准率、查全率与F1" class="headerlink" title="2.3.2 查准率、查全率与F1"></a>2.3.2 查准率、查全率与F1</h3><ul><li><strong>查准率P</strong>：被模型预测为<strong>正例</strong>的样例中有多大比例是<strong>真正例</strong>，$P&#x3D;\frac{TP}{TP+FP}$</li><li><strong>查全率R</strong>：所有<strong>正例</strong>当中有多大比例被模型预测为<strong>正例</strong>，$P&#x3D;\frac{TP}{TP+FN}$</li><li>综合考虑查准率、查全率的性能度量，利用<strong>F1度量</strong>：$F1 &#x3D; \frac{2 \times P \times R}{P+R}&#x3D; \frac{2 \times TP}{样例总数+TP-TN}$</li><li>F1度量的一般形式——$F_{\beta}&#x3D;\frac{(1+\beta^2) \times P \times R}{(\beta^2 \times P)+R}$，$\beta&gt;0$度量了查全率对查准率的相对重要性，$\beta&gt;1$时查全率有更大影响；$\beta&lt;1$时查准率有更大影响</li></ul><h3 id="2-3-3-ROC与AUC"><a href="#2-3-3-ROC与AUC" class="headerlink" title="2.3.3 ROC与AUC"></a>2.3.3 ROC与AUC</h3><ul><li><strong>ROC</strong>：受试者工作特征（<code>Receiver Operating Characteristic</code>）曲线，<code>ROC</code>曲线纵轴是“真正例率”（<code>True Positive Rate,TPR</code>），横轴是“假正例率”（<code>False Positive Rate,FPR</code>）</li></ul><p>$$<br>TPR &#x3D; \frac{TP}{TP+FN} \<br>FPR &#x3D; \frac{FP}{TN+FP}<br>$$</p><ul><li>若一个模型的<code>ROC</code>曲线被另一个模型的曲线完全“包住”，则可断言后者的性能优于前者</li><li>两个模型的<code>ROC</code>曲线发生交叉，则难以判断孰优孰劣，判断依据是比较<code>ROC</code>曲线下的面积，即<code>AUC(Area Under ROC Curve)</code></li></ul><h3 id="2-3-4-代价敏感错误率与代价曲线"><a href="#2-3-4-代价敏感错误率与代价曲线" class="headerlink" title="2.3.4 代价敏感错误率与代价曲线"></a>2.3.4 代价敏感错误率与代价曲线</h3><ul><li>为权衡不同类型错误所造成的不同损失，可为错误赋予“非均等代价”</li><li>前面的一些性能度量大都隐式地假设了均等代价。在非均等代价下，所希望的是最小化“总体代价”</li><li>在非均等代价下，<code>ROC</code>曲线不能直接反映出模型的期望总体代价，“代价曲线”则可以达到该目的。代价曲线图的横轴是取值为[0,1]的正例概率代价，纵轴是取值为[0,1]的归一化代价</li></ul><h2 id="2-4-比较检验"><a href="#2-4-比较检验" class="headerlink" title="2.4 比较检验"></a>2.4 比较检验</h2><p>以下以错误率为性能度量，用</p><h3 id="2-4-1-假设检验"><a href="#2-4-1-假设检验" class="headerlink" title="2.4.1 假设检验"></a>2.4.1 假设检验</h3><ul><li>检验中的“假设”是对模型泛化错误率分布的某种判断或猜想</li></ul><h3 id="2-4-2-交叉验证t检验"><a href="#2-4-2-交叉验证t检验" class="headerlink" title="2.4.2 交叉验证t检验"></a>2.4.2 交叉验证t检验</h3><ul><li>**基本思想：**若两个模型的性能相同，则它们使用相同的训练&#x2F;测试集得到的测试错误率应相同</li></ul><h3 id="2-4-3-McNemar检验"><a href="#2-4-3-McNemar检验" class="headerlink" title="2.4.3 McNemar检验"></a>2.4.3 McNemar检验</h3><ul><li>对二分类问题，使用留出法，不仅估计模型A和B的测试错误率，还可获得两模型分类结果的差别</li></ul><h3 id="2-4-4-Friedman检验与Nemenyi后续检验"><a href="#2-4-4-Friedman检验与Nemenyi后续检验" class="headerlink" title="2.4.4 Friedman检验与Nemenyi后续检验"></a>2.4.4 Friedman检验与Nemenyi后续检验</h3><ul><li>交叉验证t检验和McNemar检验都是在一个数据集上比较两个算法的性能</li><li>在一组数据集上对多不算法进行比较：当有多个 算法参与比较时，一种做法是在每个数据集上分别列出两两比较的结果，而在两两比较时使用前述方法；另一种方法更为直接，即使用基于算法排序的 Friedman 检验</li></ul><h2 id="2-5-偏差与方差"><a href="#2-5-偏差与方差" class="headerlink" title="2.5 偏差与方差"></a>2.5 偏差与方差</h2><ul><li>“偏差-方差分解”是解释学习算法泛化性能的一种重要工具</li><li><strong>泛化误差可分解为偏差、方差与噪声之和</strong></li><li><strong>偏差</strong>：度量了学习算法的期望预测与真实结果的偏离程度，即刻画了学习算法本身的拟合能力</li><li><strong>方差</strong>：度量了同样大小的训练集的变动所导致的学习性能的变化，即刻画了数据扰动所造成的影响</li><li><strong>噪声</strong>：表达了在当前任务上任何学习算法所能达到的期望泛化误差的下界，即刻画了学习问题本身的难度</li><li><strong>偏差-方差分解说明</strong>，泛化性能是由学习算法的能力、数据的充分性以及学习任务本身的难度所共同决定的。给定学习任务，为了取得好的泛化性能，则需使偏差较小，即能够充分拟合数据，并且使方差较小，即使得数据扰动产生的影响小</li><li>一般来说，偏差与方差是有冲突的，这称为偏差-方差窘境(bias-variance dilemma)</li></ul>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 西瓜书 </tag>
            
            <tag> 南瓜书 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>西瓜书+南瓜书——（一）绪论</title>
      <link href="/2025/08/18/%E8%A5%BF%E7%93%9C%E4%B9%A6+%E5%8D%97%E7%93%9C%E4%B9%A6%E5%AD%A6%E4%B9%A0/%E4%B8%80_%E7%BB%AA%E8%AE%BA/"/>
      <url>/2025/08/18/%E8%A5%BF%E7%93%9C%E4%B9%A6+%E5%8D%97%E7%93%9C%E4%B9%A6%E5%AD%A6%E4%B9%A0/%E4%B8%80_%E7%BB%AA%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="西瓜书-南瓜书——（一）绪论"><a href="#西瓜书-南瓜书——（一）绪论" class="headerlink" title="西瓜书+南瓜书——（一）绪论"></a>西瓜书+南瓜书——（一）绪论</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本次笔记为<code>DataWhale周志华机器学习入门</code>课程相关记录</p><p>引用资料：[1]. <a href="https://www.datawhale.cn/learn/summary/2">https://www.datawhale.cn/learn/summary/2</a><br>                   [2]. 周志华. 机器学习[M]. 北京: 清华大学出版社, 2016.</p><h2 id="1-1-引言"><a href="#1-1-引言" class="headerlink" title="1.1 引言"></a>1.1 引言</h2><p>机器学习：经验——&gt;模型的学习算法，是研究关于“学习算法”的学问</p><h2 id="1-2-基本术语"><a href="#1-2-基本术语" class="headerlink" title="1.2 基本术语"></a>1.2 基本术语</h2><ul><li><p>样本：关于一个事件或对象的描述</p></li><li><p>样本空间：也称为“输入空间”或“属性空间”。表示样本的特征向量所在的空间</p></li><li><p>数据集：集合表示，如$D&#x3D;{x_1,x_2…x_m}$表示包含$m$个样本的数据集</p></li><li><p>模型：通过训练得到的一种决策方法</p></li><li><p>标记：学习西瓜好坏时，“好瓜”和“坏瓜”便是样本的标记</p><ul><li>标记取值为离散型时，此类任务为“分类”</li><li>标记取值为连续型时，此类任务为”回归“</li><li>模型训练阶段有用到标记信息时，此类任务为”监督学习“——分类、回归</li><li>模型训练阶段没用到标记信息时，此类任务为”无监督学习“——聚类</li></ul></li><li><p>泛化：对非训练集数据的准确判断能力</p></li></ul><p><strong>数据决定模型效果的上限——数据量和特征工程</strong></p><h2 id="1-3-假设空间"><a href="#1-3-假设空间" class="headerlink" title="1.3 假设空间"></a>1.3 假设空间</h2><h3 id="a-假设与假设空间"><a href="#a-假设与假设空间" class="headerlink" title="a. 假设与假设空间"></a>a. 假设与假设空间</h3><ul><li><strong>假设（Hypothesis）</strong>：从输入 $x$ 到输出 $\hat{y}$ 的映射函数。</li><li><strong>假设空间（Hypothesis Space, $\mathcal{H}$）</strong>：所有候选假设的集合。<br>学习目标：在 $\mathcal{H}$ 中找到近似真实函数 $f(x)$ 的最佳假设。</li></ul><h3 id="b-假设空间的例子"><a href="#b-假设空间的例子" class="headerlink" title="b. 假设空间的例子"></a>b. 假设空间的例子</h3><ul><li><strong>线性回归</strong>：$h(x)&#x3D;w^\top x+b$</li><li><strong>决策树</strong>：所有可能的树结构</li><li><strong>神经网络</strong>：极大假设空间，包含不同参数组合对应的函数</li></ul><h3 id="c-假设空间的规模"><a href="#c-假设空间的规模" class="headerlink" title="c. 假设空间的规模"></a>c. 假设空间的规模</h3><ul><li><strong>有限假设空间</strong><br>例：布尔函数学习，属性数为 $n$，函数个数为 $2^{2^n}$。</li><li><strong>无限假设空间</strong><br>参数连续可取 $\Rightarrow$ 无穷多个假设（如线性模型、神经网络）。</li></ul><h3 id="d-真相与目标假设"><a href="#d-真相与目标假设" class="headerlink" title="d. 真相与目标假设"></a>d. 真相与目标假设</h3><ul><li><strong>真实目标函数 $f(x)$</strong>：客观存在，但不可直接获得。</li><li><strong>目标假设</strong>：在 $\mathcal{H}$ 中最接近 $f(x)$ 的假设。</li></ul><h2 id="1-4-归纳偏好"><a href="#1-4-归纳偏好" class="headerlink" title="1.4 归纳偏好"></a>1.4 归纳偏好</h2><h3 id="a-什么是归纳偏好"><a href="#a-什么是归纳偏好" class="headerlink" title="a. 什么是归纳偏好"></a>a. 什么是归纳偏好</h3><ul><li><strong>归纳偏好（Inductive Bias）</strong>：学习算法在多个与训练数据一致的假设中，偏好选择某些假设的倾向。</li><li>没有归纳偏好，学习是不可能的。因为仅凭有限训练样本，可能存在无数个与之兼容的假设。</li></ul><h3 id="b-为什么需要归纳偏好"><a href="#b-为什么需要归纳偏好" class="headerlink" title="b. 为什么需要归纳偏好"></a>b. 为什么需要归纳偏好</h3><ul><li><strong>训练样本有限性</strong>：不能唯一确定真实函数 $f(x)$。</li><li><strong>避免过拟合</strong>：归纳偏好帮助算法排除复杂或不合理的假设。</li><li><strong>泛化能力</strong>：好的偏好 $\Rightarrow$ 能对未见数据给出合理预测。</li></ul><h3 id="c-常见的归纳偏好类型"><a href="#c-常见的归纳偏好类型" class="headerlink" title="c. 常见的归纳偏好类型"></a>c. 常见的归纳偏好类型</h3><ul><li><strong>奥卡姆剃刀原则（Occam’s Razor）</strong>  <ul><li>偏好简单假设（更简洁的函数、较小的模型）</li><li>简单模型通常泛化性更好</li></ul></li><li><strong>平滑性假设（Continuity Assumption）</strong>  <ul><li>输入相近 $\Rightarrow$ 输出相近  </li><li>最近邻算法、核方法均依赖此偏好</li></ul></li><li><strong>参数化限制</strong>  <ul><li>如线性模型限制了假设空间，只能学习线性函数</li></ul></li><li><strong>先验知识</strong>  <ul><li>在贝叶斯学习中，通过先验分布显式编码偏好</li></ul></li></ul><h3 id="d-数学表述"><a href="#d-数学表述" class="headerlink" title="d. 数学表述"></a>d. 数学表述</h3><ul><li>给定训练集 $D&#x3D;{(x_i,y_i)}$，存在多个假设与 $D$ 一致。</li><li>若学习算法 $\mathcal{A}$ 始终选择 $h \in \mathcal{H}$，则归纳偏好可以形式化为：<br>$$<br>\text{Bias}(\mathcal{A}) &#x3D; {h \in \mathcal{H} \mid \mathcal{A}\ \text{更偏好选择}\ h}<br>$$</li></ul><h3 id="e-示例"><a href="#e-示例" class="headerlink" title="e. 示例"></a>e. 示例</h3><ul><li><strong>最近邻算法</strong>：隐含“平滑性偏好”</li><li><strong>决策树</strong>：常用信息增益&#x2F;基尼指数，隐含“简单划分优先”</li><li><strong>神经网络</strong>：结构和正则化方式体现不同的归纳偏好</li></ul>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 西瓜书 </tag>
            
            <tag> 南瓜书 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker容器网络</title>
      <link href="/2025/07/14/Docker%E5%AD%A6%E4%B9%A0/Docker%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C/"/>
      <url>/2025/07/14/Docker%E5%AD%A6%E4%B9%A0/Docker%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><p>默认情况下，所有容器都是以<code>bridge</code>方式连接到<code>Docker</code>的一个虚拟网桥上。</p><p>由于容器的重新启动会导致IP重新配置，所以为了让容器网络互连，加入自定义网络。</p><p>Docker网络操作命令如下：</p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>docker network create</code></td><td>创建一个网络</td></tr><tr><td><code>docker network ls</code></td><td>查看所有网络</td></tr><tr><td><code>docker network rm</code></td><td>删除指定网络</td></tr><tr><td><code>docker network prune</code></td><td>清除未使用的网络</td></tr><tr><td><code>docker network connect</code></td><td>使指定容器连接加入某网络</td></tr><tr><td><code>docker network disconnect</code></td><td>使指定容器连接离开某网络</td></tr><tr><td><code>docker network inspect</code></td><td>查看网络详细信息</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Docker学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dockerfile</title>
      <link href="/2025/07/14/Docker%E5%AD%A6%E4%B9%A0/Dockerfile/"/>
      <url>/2025/07/14/Docker%E5%AD%A6%E4%B9%A0/Dockerfile/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h1><p><strong><code>Dockerfile</code><strong>就是一个文本文件，其中包含一个个的</strong>指令(<code>Instruction</code>)</strong>，用指令来说明要执行什么操作来构建镜像。将来<code>Docker</code>可以根据<code>Dockerfile</code>帮我们构建镜像。常见指令如下：</p><table><thead><tr><th>指令</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td>FROM</td><td>指定基础镜像</td><td>FROM centos:6</td></tr><tr><td>ENV</td><td>设置环境变量，可在后面指令使用</td><td>ENV key value</td></tr><tr><td>COPY</td><td>拷贝本地文件到镜像的指定目录</td><td>COPY  .&#x2F;jrell.tar.gz &#x2F;tmp</td></tr><tr><td>RUN</td><td>执行Linux的shell命令，一般是安装过程的命令</td><td>RUN tar -zxvf &#x2F;tmp&#x2F;jrell.tar.gz &amp;&amp; EXPORTS path&#x3D;&#x2F;tmp&#x2F;jrell:$path</td></tr><tr><td>EXPOSE</td><td>指定容器运行时监听的端口，是给镜像使用者看的</td><td>EXPOSE 8080</td></tr><tr><td>ENTRYPOINT</td><td>镜像中应用的启动命令，容器运行时调用</td><td>ENTRYPOINT java -jar xx.jar</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Docker学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker数据卷</title>
      <link href="/2025/07/14/Docker%E5%AD%A6%E4%B9%A0/Docker%E6%95%B0%E6%8D%AE%E5%8D%B7/"/>
      <url>/2025/07/14/Docker%E5%AD%A6%E4%B9%A0/Docker%E6%95%B0%E6%8D%AE%E5%8D%B7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="数据卷-volume"><a href="#数据卷-volume" class="headerlink" title="数据卷(volume)"></a>数据卷(volume)</h1><p>一个虚拟目录，是<strong>容器内目录与宿主机目录</strong>之间映射的桥梁</p><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center"><code>docker volume create</code></td><td align="center">创建数据卷</td></tr><tr><td align="center"><code>docker volume ls</code></td><td align="center">查看所有数据卷</td></tr><tr><td align="center"><code>docker volume rm v_name</code></td><td align="center">删除指定数据卷</td></tr><tr><td align="center"><code>docker volume inspect v_name</code></td><td align="center">查某个数据卷的详情</td></tr><tr><td align="center"><code>docker volume prune</code></td><td align="center">清楚数据卷</td></tr></tbody></table><ul><li>在执行<code>docker run</code>命令时，使用**<code>-v 数据卷:容器内目录</code>**可以完成数据卷挂载</li><li>当创建容器时，如果挂载了数据卷且数据卷不存在，会自动创建数据卷</li></ul>]]></content>
      
      
      <categories>
          
          <category> Docker学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker使用</title>
      <link href="/2025/07/07/Docker%E5%AD%A6%E4%B9%A0/Docker%E4%BD%BF%E7%94%A8/"/>
      <url>/2025/07/07/Docker%E5%AD%A6%E4%B9%A0/Docker%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Docker的常用命令"><a href="#Docker的常用命令" class="headerlink" title="Docker的常用命令"></a>Docker的常用命令</h1><h2 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker version#显示docker的版本信息</span><br><span class="line">docker info#显示docker的系统信息，更详细</span><br><span class="line">docker [COMMOND] --help#显示指定命令的帮助文档</span><br></pre></td></tr></table></figure><h2 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h2><ul><li><strong><code>docker images</code></strong>查看所有本地的主机上的镜像</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\Administrator\Desktop\学习笔记\Docker学习&gt; docker images</span><br><span class="line">REPOSITORY    TAG       IMAGE ID       CREATED        SIZE</span><br><span class="line">hello-world   latest    74cc54e27dc4   5 months ago   10.1kB</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">实现指令的含义、可选项和用法，其它指令同理</span></span><br><span class="line">PS C:\Users\Administrator\Desktop\学习笔记\Docker学习&gt; docker images --help</span><br><span class="line">Usage:  docker images [OPTIONS] [REPOSITORY[:TAG]]</span><br><span class="line"></span><br><span class="line">List images</span><br><span class="line"></span><br><span class="line">Aliases:</span><br><span class="line">  docker image ls, docker image list, docker images</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -a, --all             Show all images (default hides intermediate images)</span><br><span class="line">      --digests         Show digests</span><br><span class="line">  -f, --filter filter   Filter output based on conditions provided</span><br><span class="line">      --format string   Format output using a custom template:</span><br><span class="line">                        &#x27;table&#x27;:            Print output in table format</span><br><span class="line">                        with column headers (default)</span><br><span class="line">                        &#x27;table TEMPLATE&#x27;:   Print output in table format</span><br><span class="line">                        using the given Go template</span><br><span class="line">                        &#x27;json&#x27;:             Print in JSON format</span><br><span class="line">                        &#x27;TEMPLATE&#x27;:         Print output using the given</span><br><span class="line">                        Go template.</span><br><span class="line">                        Refer to https://docs.docker.com/go/formatting/</span><br><span class="line">                        for more information about formatting output with</span><br><span class="line">                        templates</span><br><span class="line">      --no-trunc        Don&#x27;t truncate output</span><br><span class="line">  -q, --quiet           Only show image IDs</span><br><span class="line">      --tree            List multi-platform images as a tree (EXPERIMENTAL)</span><br></pre></td></tr></table></figure><ul><li><strong><code>docker search</code></strong>搜索镜像</li></ul><p>这个指令来搜索和在网站仓库搜索是一样的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker search image_name [options]</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">eg</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">docker search mysql</span></span><br></pre></td></tr></table></figure><ul><li><strong><code>docker pull</code></strong>下载镜像</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">docker pull image_name [options]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">示例</span></span><br><span class="line">PS C:\Users\Administrator\Desktop\学习笔记\Docker学习&gt; docker pull mysql</span><br><span class="line">Using default tag: latest# 默认最新版本</span><br><span class="line">latest: Pulling from library/mysql</span><br><span class="line">ed0a8990cecb: Pull complete# 分层下载</span><br><span class="line">7af7a034b8b9: Pull complete</span><br><span class="line">87129af36c90: Pull complete</span><br><span class="line">10cecf14f09b: Pull complete</span><br><span class="line">028720beb240: Pull complete</span><br><span class="line">bfba8db0f2bd: Pull complete</span><br><span class="line">ead6a62c24e9: Pull complete</span><br><span class="line">d20478bf3bbf: Pull complete</span><br><span class="line">7a26ee8a4dfe: Pull complete</span><br><span class="line">4657dc0fd6ee: Pull complete</span><br><span class="line">Digest: sha256:9a084cc73e7186283c564875e08d8af2c0e5c925333ad0a713f02fb1d826f78a# 签名</span><br><span class="line">Status: Downloaded newer image for mysql:latest</span><br><span class="line">docker.io/library/mysql:latest# 真实地址</span><br></pre></td></tr></table></figure><ul><li><strong><code>docker rmi</code></strong>删除镜像</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker rmi -f IMAGE_ID# 删除指定ID的镜像</span><br><span class="line">docker rmi -f $(docker images -aq)# 删除所有镜像</span><br></pre></td></tr></table></figure><ul><li><strong><code>docker save</code></strong>保存镜像文件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">保存镜像在本地，删除了之后，可以直接load加载回来，不需要再pull下来</span></span><br><span class="line">docker save -o image.tar image_name</span><br></pre></td></tr></table></figure><ul><li><strong><code>docker load</code></strong>加载镜像</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker load -i image.tar</span><br></pre></td></tr></table></figure><h2 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h2><p><strong>说明：有了镜像才可以创建容器</strong></p><ul><li><strong><code>docker run</code></strong><strong>新建容器并启动</strong></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">docker run [options] image_name</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">参数说明</span></span><br><span class="line">--name=&quot;Name&quot;容器名字 tomcat1 tomcat2. 用来区分容器</span><br><span class="line">-d后台方式运行</span><br><span class="line">-it使用交互方式运行，进入容器查看内容</span><br><span class="line">-p指定容器的端口</span><br><span class="line">-p ip:主机端口:容器端口</span><br><span class="line">-p 主机端口:容器端口(常用)</span><br><span class="line">-p 容器端口</span><br><span class="line">-P随机指定端口</span><br></pre></td></tr></table></figure><ul><li><strong>退出容器</strong></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">exit# 容器停止并退出</span><br><span class="line">Ctrl + P + Q# 容器不停止退出</span><br></pre></td></tr></table></figure><ul><li><strong><code>docker ps</code></strong><strong>查看运行的容器</strong></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker ps [options]# 列出当前运行的容器</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">参数说明</span></span><br><span class="line">-a# 列出当前正在运行的+历史运行的容器</span><br><span class="line">-n=?# 列出最近创建的n个容器</span><br><span class="line">-q# 只显示容器的编号</span><br></pre></td></tr></table></figure><ul><li><strong><code>docker rm</code></strong><strong>删除容器</strong></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker rm 容器id# 删除指定id的容器</span><br><span class="line">docker rm -f $(docker ps -aq)# 删除全部容器，后面$中就是指定了所有的容器id</span><br></pre></td></tr></table></figure><ul><li><strong>启动和停止容器的操作</strong></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker start 容器id# 启动容器</span><br><span class="line">docker restart 容器id# 重启容器</span><br><span class="line">docker stop 容器id# 停止当前正在运行的容器</span><br><span class="line">docker kill 容器id# 强制停止当前容器</span><br></pre></td></tr></table></figure><h2 id="常用其它命令"><a href="#常用其它命令" class="headerlink" title="常用其它命令"></a>常用其它命令</h2><ul><li><strong>后台启动容器</strong></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -d image_name</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">问题docker ps 发现这个启动的容器关闭了</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">常见的坑，docker容器使用后台运行，就必须要有一个前台进程，docker发现没有应用，就会自动停止</span></span><br></pre></td></tr></table></figure><ul><li><strong>查看日志</strong></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs [options] 容器id</span><br></pre></td></tr></table></figure><ul><li><strong>查看容器中进程信息</strong></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker top 容器id</span><br></pre></td></tr></table></figure><ul><li><strong>查看镜像的元数据</strong></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br></pre></td><td class="code"><pre><span class="line">docker inspect [options] 容器id</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">测试</span></span><br><span class="line">PS C:\Users\Administrator\Desktop\学习笔记\Docker学习&gt; docker inspect b45c0c1cb9c7</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Id&quot;: &quot;b45c0c1cb9c73e64b634e694783f8f6f2ca1c2787294910e0d4698f3072db200&quot;,</span><br><span class="line">        &quot;Created&quot;: &quot;2025-06-30T13:10:09.654201198Z&quot;,</span><br><span class="line">        &quot;Path&quot;: &quot;/bin/bash&quot;,</span><br><span class="line">        &quot;Args&quot;: [],</span><br><span class="line">        &quot;State&quot;: &#123;</span><br><span class="line">            &quot;Status&quot;: &quot;running&quot;,</span><br><span class="line">            &quot;Running&quot;: true,</span><br><span class="line">            &quot;Paused&quot;: false,</span><br><span class="line">            &quot;Restarting&quot;: false,</span><br><span class="line">            &quot;OOMKilled&quot;: false,</span><br><span class="line">            &quot;Dead&quot;: false,</span><br><span class="line">            &quot;Pid&quot;: 2060,</span><br><span class="line">            &quot;ExitCode&quot;: 0,</span><br><span class="line">            &quot;Error&quot;: &quot;&quot;,</span><br><span class="line">            &quot;StartedAt&quot;: &quot;2025-06-30T13:22:25.91560843Z&quot;,</span><br><span class="line">            &quot;FinishedAt&quot;: &quot;2025-06-30T13:22:09.976525914Z&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Image&quot;: &quot;sha256:eeb6ee3f44bd0b5103bb561b4c16bcb82328cfe5809ab675bb17ab3a16c517c9&quot;,</span><br><span class="line">        &quot;ResolvConfPath&quot;: &quot;/var/lib/docker/containers/b45c0c1cb9c73e64b634e694783f8f6f2ca1c2787294910e0d4698f3072db200/resolv.conf&quot;,</span><br><span class="line">        &quot;HostnamePath&quot;: &quot;/var/lib/docker/containers/b45c0c1cb9c73e64b634e694783f8f6f2ca1c2787294910e0d4698f3072db200/hostname&quot;,</span><br><span class="line">        &quot;HostsPath&quot;: &quot;/var/lib/docker/containers/b45c0c1cb9c73e64b634e694783f8f6f2ca1c2787294910e0d4698f3072db200/hosts&quot;,</span><br><span class="line">        &quot;LogPath&quot;: &quot;/var/lib/docker/containers/b45c0c1cb9c73e64b634e694783f8f6f2ca1c2787294910e0d4698f3072db200/b45c0c1cb9c73e64b634e694783f8f6f2ca1c2787294910e0d4698f3072db200-json.log&quot;,</span><br><span class="line">        &quot;Name&quot;: &quot;/stupefied_mirzakhani&quot;,</span><br><span class="line">        &quot;RestartCount&quot;: 0,</span><br><span class="line">        &quot;Driver&quot;: &quot;overlay2&quot;,</span><br><span class="line">        &quot;Platform&quot;: &quot;linux&quot;,</span><br><span class="line">        &quot;MountLabel&quot;: &quot;&quot;,</span><br><span class="line">        &quot;ProcessLabel&quot;: &quot;&quot;,</span><br><span class="line">        &quot;AppArmorProfile&quot;: &quot;&quot;,</span><br><span class="line">        &quot;ExecIDs&quot;: null,</span><br><span class="line">        &quot;HostConfig&quot;: &#123;</span><br><span class="line">            &quot;Binds&quot;: null,</span><br><span class="line">            &quot;ContainerIDFile&quot;: &quot;&quot;,</span><br><span class="line">            &quot;LogConfig&quot;: &#123;</span><br><span class="line">                &quot;Type&quot;: &quot;json-file&quot;,</span><br><span class="line">                &quot;Config&quot;: &#123;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;NetworkMode&quot;: &quot;bridge&quot;,</span><br><span class="line">            &quot;PortBindings&quot;: &#123;&#125;,</span><br><span class="line">            &quot;RestartPolicy&quot;: &#123;</span><br><span class="line">                &quot;Name&quot;: &quot;no&quot;,</span><br><span class="line">                &quot;MaximumRetryCount&quot;: 0</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;AutoRemove&quot;: false,</span><br><span class="line">            &quot;VolumeDriver&quot;: &quot;&quot;,</span><br><span class="line">            &quot;VolumesFrom&quot;: null,</span><br><span class="line">            &quot;ConsoleSize&quot;: [</span><br><span class="line">                51,</span><br><span class="line">                121</span><br><span class="line">            ],</span><br><span class="line">            &quot;CapAdd&quot;: null,</span><br><span class="line">            &quot;CapDrop&quot;: null,</span><br><span class="line">            &quot;CgroupnsMode&quot;: &quot;private&quot;,</span><br><span class="line">            &quot;Dns&quot;: [],</span><br><span class="line">            &quot;DnsOptions&quot;: [],</span><br><span class="line">            &quot;DnsSearch&quot;: [],</span><br><span class="line">            &quot;ExtraHosts&quot;: null,</span><br><span class="line">            &quot;GroupAdd&quot;: null,</span><br><span class="line">            &quot;IpcMode&quot;: &quot;private&quot;,</span><br><span class="line">            &quot;Cgroup&quot;: &quot;&quot;,</span><br><span class="line">            &quot;Links&quot;: null,</span><br><span class="line">            &quot;OomScoreAdj&quot;: 0,</span><br><span class="line">            &quot;PidMode&quot;: &quot;&quot;,</span><br><span class="line">            &quot;Privileged&quot;: false,</span><br><span class="line">            &quot;PublishAllPorts&quot;: false,</span><br><span class="line">            &quot;ReadonlyRootfs&quot;: false,</span><br><span class="line">            &quot;SecurityOpt&quot;: null,</span><br><span class="line">            &quot;UTSMode&quot;: &quot;&quot;,</span><br><span class="line">            &quot;UsernsMode&quot;: &quot;&quot;,</span><br><span class="line">            &quot;ShmSize&quot;: 67108864,</span><br><span class="line">            &quot;Runtime&quot;: &quot;runc&quot;,</span><br><span class="line">            &quot;Isolation&quot;: &quot;&quot;,</span><br><span class="line">            &quot;CpuShares&quot;: 0,</span><br><span class="line">            &quot;Memory&quot;: 0,</span><br><span class="line">            &quot;NanoCpus&quot;: 0,</span><br><span class="line">            &quot;CgroupParent&quot;: &quot;&quot;,</span><br><span class="line">            &quot;BlkioWeight&quot;: 0,</span><br><span class="line">            &quot;BlkioWeightDevice&quot;: [],</span><br><span class="line">            &quot;BlkioDeviceReadBps&quot;: [],</span><br><span class="line">            &quot;BlkioDeviceWriteBps&quot;: [],</span><br><span class="line">            &quot;BlkioDeviceReadIOps&quot;: [],</span><br><span class="line">            &quot;BlkioDeviceWriteIOps&quot;: [],</span><br><span class="line">            &quot;CpuPeriod&quot;: 0,</span><br><span class="line">            &quot;CpuQuota&quot;: 0,</span><br><span class="line">            &quot;CpuRealtimePeriod&quot;: 0,</span><br><span class="line">            &quot;CpuRealtimeRuntime&quot;: 0,</span><br><span class="line">            &quot;CpusetCpus&quot;: &quot;&quot;,</span><br><span class="line">            &quot;CpusetMems&quot;: &quot;&quot;,</span><br><span class="line">            &quot;Devices&quot;: [],</span><br><span class="line">            &quot;DeviceCgroupRules&quot;: null,</span><br><span class="line">            &quot;DeviceRequests&quot;: null,</span><br><span class="line">            &quot;MemoryReservation&quot;: 0,</span><br><span class="line">            &quot;MemorySwap&quot;: 0,</span><br><span class="line">            &quot;MemorySwappiness&quot;: null,</span><br><span class="line">            &quot;OomKillDisable&quot;: null,</span><br><span class="line">            &quot;PidsLimit&quot;: null,</span><br><span class="line">            &quot;Ulimits&quot;: [],</span><br><span class="line">            &quot;CpuCount&quot;: 0,</span><br><span class="line">            &quot;CpuPercent&quot;: 0,</span><br><span class="line">            &quot;IOMaximumIOps&quot;: 0,</span><br><span class="line">            &quot;IOMaximumBandwidth&quot;: 0,</span><br><span class="line">            &quot;MaskedPaths&quot;: [</span><br><span class="line">                &quot;/proc/asound&quot;,</span><br><span class="line">                &quot;/proc/acpi&quot;,</span><br><span class="line">                &quot;/proc/interrupts&quot;,</span><br><span class="line">                &quot;/proc/kcore&quot;,</span><br><span class="line">                &quot;/proc/keys&quot;,</span><br><span class="line">                &quot;/proc/latency_stats&quot;,</span><br><span class="line">                &quot;/proc/timer_list&quot;,</span><br><span class="line">                &quot;/proc/timer_stats&quot;,</span><br><span class="line">                &quot;/proc/sched_debug&quot;,</span><br><span class="line">                &quot;/proc/scsi&quot;,</span><br><span class="line">                &quot;/sys/firmware&quot;,</span><br><span class="line">                &quot;/sys/devices/virtual/powercap&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;ReadonlyPaths&quot;: [</span><br><span class="line">                &quot;/proc/bus&quot;,</span><br><span class="line">                &quot;/proc/fs&quot;,</span><br><span class="line">                &quot;/proc/irq&quot;,</span><br><span class="line">                &quot;/proc/sys&quot;,</span><br><span class="line">                &quot;/proc/sysrq-trigger&quot;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;GraphDriver&quot;: &#123;</span><br><span class="line">            &quot;Data&quot;: &#123;</span><br><span class="line">                &quot;ID&quot;: &quot;b45c0c1cb9c73e64b634e694783f8f6f2ca1c2787294910e0d4698f3072db200&quot;,</span><br><span class="line">                &quot;LowerDir&quot;: &quot;/var/lib/docker/overlay2/6a8f91234dcfbeae2f68f872b317f22a4b920e3e260022b015b00234d1bd03b1-init/diff:/var/lib/docker/overlay2/a82858cefa2ad5c97dc95f5426e56bc7060e27909fafd99ba603cec12f590810/diff&quot;,</span><br><span class="line">                &quot;MergedDir&quot;: &quot;/var/lib/docker/overlay2/6a8f91234dcfbeae2f68f872b317f22a4b920e3e260022b015b00234d1bd03b1/merged&quot;,</span><br><span class="line">                &quot;UpperDir&quot;: &quot;/var/lib/docker/overlay2/6a8f91234dcfbeae2f68f872b317f22a4b920e3e260022b015b00234d1bd03b1/diff&quot;,</span><br><span class="line">                &quot;WorkDir&quot;: &quot;/var/lib/docker/overlay2/6a8f91234dcfbeae2f68f872b317f22a4b920e3e260022b015b00234d1bd03b1/work&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;Name&quot;: &quot;overlay2&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Mounts&quot;: [],</span><br><span class="line">        &quot;Config&quot;: &#123;</span><br><span class="line">            &quot;Hostname&quot;: &quot;b45c0c1cb9c7&quot;,</span><br><span class="line">            &quot;Domainname&quot;: &quot;&quot;,</span><br><span class="line">            &quot;User&quot;: &quot;&quot;,</span><br><span class="line">            &quot;AttachStdin&quot;: true,</span><br><span class="line">            &quot;AttachStdout&quot;: true,</span><br><span class="line">            &quot;AttachStderr&quot;: true,</span><br><span class="line">            &quot;Tty&quot;: true,</span><br><span class="line">            &quot;OpenStdin&quot;: true,</span><br><span class="line">            &quot;StdinOnce&quot;: true,</span><br><span class="line">            &quot;Env&quot;: [</span><br><span class="line">                &quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;Cmd&quot;: [</span><br><span class="line">                &quot;/bin/bash&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;Image&quot;: &quot;centos:7&quot;,</span><br><span class="line">            &quot;Volumes&quot;: null,</span><br><span class="line">            &quot;WorkingDir&quot;: &quot;&quot;,</span><br><span class="line">            &quot;Entrypoint&quot;: null,</span><br><span class="line">            &quot;OnBuild&quot;: null,</span><br><span class="line">            &quot;Labels&quot;: &#123;</span><br><span class="line">                &quot;org.label-schema.build-date&quot;: &quot;20201113&quot;,</span><br><span class="line">                &quot;org.label-schema.license&quot;: &quot;GPLv2&quot;,</span><br><span class="line">                &quot;org.label-schema.name&quot;: &quot;CentOS Base Image&quot;,</span><br><span class="line">                &quot;org.label-schema.schema-version&quot;: &quot;1.0&quot;,</span><br><span class="line">                &quot;org.label-schema.vendor&quot;: &quot;CentOS&quot;,</span><br><span class="line">                &quot;org.opencontainers.image.created&quot;: &quot;2020-11-13 00:00:00+00:00&quot;,</span><br><span class="line">                &quot;org.opencontainers.image.licenses&quot;: &quot;GPL-2.0-only&quot;,</span><br><span class="line">                &quot;org.opencontainers.image.title&quot;: &quot;CentOS Base Image&quot;,</span><br><span class="line">                &quot;org.opencontainers.image.vendor&quot;: &quot;CentOS&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;NetworkSettings&quot;: &#123;</span><br><span class="line">            &quot;Bridge&quot;: &quot;&quot;,</span><br><span class="line">            &quot;SandboxID&quot;: &quot;87a6d0137cc6eee6bca89d1325c262e4f271879588d5d8fbd36c6659c9886f1a&quot;,</span><br><span class="line">            &quot;SandboxKey&quot;: &quot;/var/run/docker/netns/87a6d0137cc6&quot;,</span><br><span class="line">            &quot;Ports&quot;: &#123;&#125;,</span><br><span class="line">            &quot;HairpinMode&quot;: false,</span><br><span class="line">            &quot;LinkLocalIPv6Address&quot;: &quot;&quot;,</span><br><span class="line">            &quot;LinkLocalIPv6PrefixLen&quot;: 0,</span><br><span class="line">            &quot;SecondaryIPAddresses&quot;: null,</span><br><span class="line">            &quot;SecondaryIPv6Addresses&quot;: null,</span><br><span class="line">            &quot;EndpointID&quot;: &quot;ffa92545d2319c1fa3a8bc2cab7d5fe4d36b9133af8f88780ebdd62552ba5f52&quot;,</span><br><span class="line">            &quot;Gateway&quot;: &quot;172.17.0.1&quot;,</span><br><span class="line">            &quot;GlobalIPv6Address&quot;: &quot;&quot;,</span><br><span class="line">            &quot;GlobalIPv6PrefixLen&quot;: 0,</span><br><span class="line">            &quot;IPAddress&quot;: &quot;172.17.0.2&quot;,</span><br><span class="line">            &quot;IPPrefixLen&quot;: 16,</span><br><span class="line">            &quot;IPv6Gateway&quot;: &quot;&quot;,</span><br><span class="line">            &quot;MacAddress&quot;: &quot;32:b1:08:6b:76:9d&quot;,</span><br><span class="line">            &quot;Networks&quot;: &#123;</span><br><span class="line">                &quot;bridge&quot;: &#123;</span><br><span class="line">                    &quot;IPAMConfig&quot;: null,</span><br><span class="line">                    &quot;Links&quot;: null,</span><br><span class="line">                    &quot;Aliases&quot;: null,</span><br><span class="line">                    &quot;MacAddress&quot;: &quot;32:b1:08:6b:76:9d&quot;,</span><br><span class="line">                    &quot;DriverOpts&quot;: null,</span><br><span class="line">                    &quot;GwPriority&quot;: 0,</span><br><span class="line">                    &quot;NetworkID&quot;: &quot;68a33238bde2b2c25b345eda54698fc7fc670c8654751177c79f7f457dcf20a6&quot;,</span><br><span class="line">                    &quot;EndpointID&quot;: &quot;ffa92545d2319c1fa3a8bc2cab7d5fe4d36b9133af8f88780ebdd62552ba5f52&quot;,</span><br><span class="line">                    &quot;Gateway&quot;: &quot;172.17.0.1&quot;,</span><br><span class="line">                    &quot;IPAddress&quot;: &quot;172.17.0.2&quot;,</span><br><span class="line">                    &quot;IPPrefixLen&quot;: 16,</span><br><span class="line">                    &quot;IPv6Gateway&quot;: &quot;&quot;,</span><br><span class="line">                    &quot;GlobalIPv6Address&quot;: &quot;&quot;,</span><br><span class="line">                    &quot;GlobalIPv6PrefixLen&quot;: 0,</span><br><span class="line">                    &quot;DNSNames&quot;: null</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><ul><li><strong>进入当前正在运行的容器</strong></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">通常容器是使用后台方式运行的，需要进入容器，修改一些配置</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">方式1</span></span><br><span class="line">docker exec -it 容器id bashshell</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">方式2</span></span><br><span class="line">docker attach 容器id</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">docker <span class="built_in">exec</span><span class="comment"># 进入容器后开启一个新的终端，可以在里面操作</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">docker attach<span class="comment"># 进入容器正在执行的终端，不会启动新的进程</span></span></span><br></pre></td></tr></table></figure><ul><li><strong>从容器内拷贝文件到主机上</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp 容器id：容器内路径 目的主机路径</span><br></pre></td></tr></table></figure><h2 id="常用命令小结"><a href="#常用命令小结" class="headerlink" title="常用命令小结"></a>常用命令小结</h2><p><img src="/post_image/Docker%E5%AD%A6%E4%B9%A0/docker%E5%91%BD%E4%BB%A4%E7%A4%BA%E6%84%8F.png" alt="docker命令示意"></p><h2 id="作业一：部署Nginx"><a href="#作业一：部署Nginx" class="headerlink" title="作业一：部署Nginx"></a>作业一：部署Nginx</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1、 搜索镜像search建议去dockerhub搜索，可以看到版本和帮助文档</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">2、 下载镜像pull</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">3、 运行测试run</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-d后台运行</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--name给容器命名</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-p</span></span><br><span class="line">PS C:\Users\Administrator\Desktop\学习笔记\Docker学习&gt; docker run -d --name nginx01 -p 3344:80 nginx</span><br><span class="line">a86ac292c192c600b3e9d1325be24fc403f594d073afdaee882e5eee3378daf6</span><br><span class="line">PS C:\Users\Administrator\Desktop\学习笔记\Docker学习&gt; docker ps</span><br><span class="line">CONTAINER ID   IMAGE     COMMAND                   CREATED          STATUS          PORTS                  NAMES</span><br><span class="line">a86ac292c192   nginx     &quot;/docker-entrypoint.…&quot;   13 seconds ago   Up 12 seconds   0.0.0.0:3344-&gt;80/tcp   nginx01</span><br></pre></td></tr></table></figure><h2 id="作业二：部署Tomcat"><a href="#作业二：部署Tomcat" class="headerlink" title="作业二：部署Tomcat"></a>作业二：部署Tomcat</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">官方的使用</span></span><br><span class="line">docker run -it --rm tomcat:9.0# --rm 会把容器用完就删除，一般用来测试</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下载再启动</span></span><br><span class="line">docker pull tomcat</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动运行</span></span><br><span class="line">docker run -d -p 3355:8080 --name tomcat01 tomcat</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">测试访问</span></span><br><span class="line">URL：localhost:3355 # 访问没有问题，404是因为官方版是阉割版tomcat</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入容器</span></span><br><span class="line">PS C:\Users\Administrator\Desktop\学习笔记\Docker学习&gt; docker exec -it tomcat01 /bin/bash</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">发现问题</span></span><br><span class="line">webapps下没有内容 拷贝进去 cp -r webapps.dist/* webapps，就可以看到了localhost:3355</span><br></pre></td></tr></table></figure><h2 id="作业三：部署ES-Kibana"><a href="#作业三：部署ES-Kibana" class="headerlink" title="作业三：部署ES+Kibana"></a>作业三：部署ES+Kibana</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">es 暴露的端口很多！十分耗内存</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">es 的数据一般需要放置在安全目录！挂载</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动 elasticsearch</span></span><br><span class="line">docker run -d --name elasticsearch -p 9200:9200 -p 9300:9300 -e &quot;discovery.types=single-node&quot; elasticsearch:7.6.2</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">测试es  成功</span></span><br><span class="line">Invoke-WebRequest -Uri http://localhost:9200</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">docker stats 查看cpu的状态，看内存占比</span></span><br><span class="line">docker stats</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">要是内存占比高，就修改配置文件，限制内存 -e</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建 Kibana 容器并连接到 Elasticsearch，版本匹配</span></span><br><span class="line">docker run -d --name kibana --network es-net -p 5601:5601 -e ELASTICSEARCH_HOSTS=http://elasticsearch:9200 kibana:7.6.2</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">验证容器网络连接</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建网络</span></span><br><span class="line">docker network create es-net</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重新启动Elasticsearch并加入网络</span></span><br><span class="line">docker stop elasticsearch</span><br><span class="line">docker rm elasticsearch</span><br><span class="line">docker run -d --name elasticsearch --network es-net -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; elasticsearch:7.6.2</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重新启动Kibana并加入网络</span></span><br><span class="line">docker stop kibana</span><br><span class="line">docker rm kibana</span><br><span class="line">docker run -d --name kibana --network es-net -p 5601:5601 -e ELASTICSEARCH_HOSTS=http://elasticsearch:9200 kibana:7.6.2</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">访问 Kibana 界面</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">访问：http://localhost:5601，首次加载可能需要 1-2 分钟，直到看到 Kibana 控制台，如果看到登录界面，说明连接成功</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Docker学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker安装</title>
      <link href="/2025/06/30/Docker%E5%AD%A6%E4%B9%A0/Docker%E5%AE%89%E8%A3%85/"/>
      <url>/2025/06/30/Docker%E5%AD%A6%E4%B9%A0/Docker%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Windows-Docker-安装"><a href="#Windows-Docker-安装" class="headerlink" title="Windows Docker 安装"></a>Windows Docker 安装</h1><p>Docker 并非是一个通用的容器工具，它依赖于已存在并运行的 Linux 内核环境。</p><p>Docker 实质上是在已经运行的 Linux 下制造了一个隔离的文件环境，因此它执行的效率几乎等同于所部署的 Linux 主机。</p><p>因此，Docker <strong>必须部署在 Linux 内核</strong>的系统上。如果其他系统想部署 Docker 就必须安装一个虚拟 Linux 环境。</p><ol><li>这里选择<strong>WSL(<code>Windows Subsystem for Linux</code>)</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --version</span><br></pre></td></tr></table></figure><ol start="2"><li>在 <a href="https://hub.docker.com/?overlay=onboarding">Get started with Docker Desktop</a>下载安装Docker Desktop的Windows版本</li><li>打开Docker Desktop，测试</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure><p><img src="/post_image/Docker%E5%AD%A6%E4%B9%A0/docker_helloworld.png" alt="docker_helloworld"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><p><img src="/post_image/Docker%E5%AD%A6%E4%B9%A0/docker_images.png" alt="docker_images"></p><h1 id="Docker-镜像加速"><a href="#Docker-镜像加速" class="headerlink" title="Docker 镜像加速"></a>Docker 镜像加速</h1><p>Docker 官方和国内很多云服务商都提供了国内加速器服务</p><ul><li>科大镜像：<strong><a href="https://docker.mirrors.ustc.edu.cn/">https://docker.mirrors.ustc.edu.cn/</a></strong></li><li>网易：<strong><a href="https://hub-mirror.c.163.com/">https://hub-mirror.c.163.com/</a></strong></li><li>阿里云：<strong>https:&#x2F;&#x2F;&lt;你的ID&gt;.mirror.aliyuncs.com</strong></li><li>七牛云加速器：<strong><a href="https://reg-mirror.qiniu.com/">https://reg-mirror.qiniu.com</a></strong></li></ul><p><strong>常用的是阿里云</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检查加速器是否生效</span></span><br><span class="line">docker info</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出有这栏信息</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Registry Mirrors:</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   https://reg-mirror.qiniu.com   --自己配置的镜像地址</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Docker学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker基础</title>
      <link href="/2025/06/30/Docker%E5%AD%A6%E4%B9%A0/Docker%E5%9F%BA%E7%A1%80/"/>
      <url>/2025/06/30/Docker%E5%AD%A6%E4%B9%A0/Docker%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Docker概念"><a href="#Docker概念" class="headerlink" title="Docker概念"></a>Docker概念</h1><h2 id="Docker基础概念"><a href="#Docker基础概念" class="headerlink" title="Docker基础概念"></a>Docker基础概念</h2><h3 id="什么是容器化技术？"><a href="#什么是容器化技术？" class="headerlink" title="什么是容器化技术？"></a>什么是容器化技术？</h3><p>容器<strong>共享主机内核，轻量、隔离且高效</strong>，不像虚拟机需要完整的操作系统</p><h3 id="为什么引入Docker？"><a href="#为什么引入Docker？" class="headerlink" title="为什么引入Docker？"></a>为什么引入Docker？</h3><h4 id="1-传统应用部署的痛点"><a href="#1-传统应用部署的痛点" class="headerlink" title="1. 传统应用部署的痛点"></a>1. 传统应用部署的痛点</h4><ul><li><strong>环境不一致</strong>：应用在开发环境运行正常，但在测试或生产环境出现问题</li><li><strong>依赖管理复杂</strong>：不同应用需要不同版本的运行时、库文件等</li><li><strong>资源利用率低</strong>：传统虚拟机需要完整的操作系统，占用大量资源</li><li><strong>部署复杂</strong>：需要手动配置环境、安装依赖，容易出错</li></ul><h4 id="2-容器化技术的解决方案"><a href="#2-容器化技术的解决方案" class="headerlink" title="2.容器化技术的解决方案"></a>2.容器化技术的解决方案</h4><ul><li><strong>环境标准化</strong>：将应用及其依赖打包在一起，确保在任何环境中都能一致运行</li><li><strong>轻量级</strong>：容器共享宿主机的操作系统内核，比虚拟机更轻量</li><li><strong>快速部署</strong>：容器可以在几秒内启动，大大提高了部署效率</li><li><strong>可移植性</strong>：一次构建，到处运行</li></ul><h4 id="3-容器化的核心理念"><a href="#3-容器化的核心理念" class="headerlink" title="3.容器化的核心理念"></a>3.容器化的核心理念</h4><ul><li>应用和环境被打包成不可变的镜像</li><li>每次部署都使用相同的镜像</li><li>配置通过环境变量或配置文件注入</li><li>问题修复通过重新构建镜像而非修改运行中的容器</li></ul><hr><h2 id="Docker的核心概念"><a href="#Docker的核心概念" class="headerlink" title="Docker的核心概念"></a>Docker的核心概念</h2><h3 id="1、镜像-Image"><a href="#1、镜像-Image" class="headerlink" title="1、镜像 (Image)"></a>1、镜像 (Image)</h3><p><strong>定义</strong>：镜像是一个只读的模板，包含了运行应用所需的所有内容：代码、运行时、库文件、环境变量和配置文件。</p><p><strong>特点</strong>：</p><ul><li><strong>分层存储</strong>：镜像由多个层组成，每一层代表一次修改</li><li><strong>只读性</strong>：镜像本身是只读的，不能直接修改</li><li><strong>可复用</strong>：同一个镜像可以创建多个容器</li><li><strong>版本管理</strong>：通过标签(tag)进行版本管理</li></ul><p><strong>类比理解</strong>：镜像就像是一个安装程序或者模板，它定义了应用运行所需的一切，但本身不能直接运行。</p><h3 id="2、容器-Container"><a href="#2、容器-Container" class="headerlink" title="2、容器 (Container)"></a>2、容器 (Container)</h3><p><strong>定义</strong>：容器是镜像的运行实例，是一个轻量级、可移植的执行环境。</p><p><strong>特点</strong>：</p><ul><li><strong>隔离性</strong>：每个容器都有自己的文件系统、网络和进程空间</li><li><strong>临时性</strong>：容器可以被创建、启动、停止、删除</li><li><strong>可写层</strong>：容器在镜像基础上添加了一个可写层</li><li><strong>进程级</strong>：容器内通常运行一个主进程</li></ul><p><strong>类比理解</strong>：如果镜像是类，那么容器就是对象实例。一个镜像可以创建多个容器，就像一个类可以创建多个对象。</p><h3 id="3、仓库-Repository"><a href="#3、仓库-Repository" class="headerlink" title="3、仓库 (Repository)"></a>3、仓库 (Repository)</h3><p><strong>定义</strong>：仓库是存储和分发镜像的地方，可以包含一个镜像的多个版本。</p><p><strong>分类</strong>：</p><ul><li><strong>公共仓库</strong>：如 <code>Docker Hub</code>，任何人都可以使用</li><li><strong>私有仓库</strong>：企业内部搭建，用于存储私有镜像</li><li><strong>官方仓库</strong>：由软件官方维护的镜像仓库</li></ul><p><strong>Registry vs Repository</strong>：</p><ul><li><strong>Registry</strong>：仓库注册服务器，如 <code>Docker Hub</code></li><li><strong>Repository</strong>：具体的镜像仓库，如 <code>nginx</code>、<code>mysql</code></li></ul><h2 id="Docker与虚拟机的区别"><a href="#Docker与虚拟机的区别" class="headerlink" title="Docker与虚拟机的区别"></a>Docker与虚拟机的区别</h2><h3 id="1、架构对比"><a href="#1、架构对比" class="headerlink" title="1、架构对比"></a>1、架构对比</h3><table><thead><tr><th align="left">特性</th><th align="left">虚拟机</th><th align="left">Docker容器</th></tr></thead><tbody><tr><td align="left">隔离级别</td><td align="left">硬件级别虚拟化</td><td align="left">操作系统级别虚拟化</td></tr><tr><td align="left">操作系统</td><td align="left">每个VM需要完整OS</td><td align="left">共享宿主机OS内核</td></tr><tr><td align="left">资源占用</td><td align="left">重量级，占用较多资源</td><td align="left">轻量级，资源占用少</td></tr><tr><td align="left">启动时间</td><td align="left">分钟级别</td><td align="left">秒级别</td></tr><tr><td align="left">性能开销</td><td align="left">较大</td><td align="left">接近原生性能</td></tr><tr><td align="left">镜像大小</td><td align="left">GB级别</td><td align="left">MB级别</td></tr></tbody></table><h3 id="2、容器-VS-虚拟机架构"><a href="#2、容器-VS-虚拟机架构" class="headerlink" title="2、容器 VS 虚拟机架构"></a>2、容器 VS 虚拟机架构</h3><p><img src="/post_image/Docker%E5%AD%A6%E4%B9%A0/%E5%AE%B9%E5%99%A8vs%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%9E%B6%E6%9E%84.png" alt="容器vs虚拟机架构"></p><h2 id="Docker的优势和应用场景"><a href="#Docker的优势和应用场景" class="headerlink" title="Docker的优势和应用场景"></a>Docker的优势和应用场景</h2><h3 id="主要优势"><a href="#主要优势" class="headerlink" title="主要优势"></a>主要优势</h3><h4 id="1-环境一致性"><a href="#1-环境一致性" class="headerlink" title="1. 环境一致性"></a>1. 环境一致性</h4><ul><li><strong>问题解决</strong>：”在我机器上能运行”的问题</li><li><strong>实现方式</strong>：应用和环境打包在一起</li><li><strong>价值</strong>：减少环境相关的bug和部署问题</li></ul><h4 id="2-轻量级和高效"><a href="#2-轻量级和高效" class="headerlink" title="2. 轻量级和高效"></a>2. 轻量级和高效</h4><ul><li><strong>资源利用</strong>：比虚拟机占用更少资源</li><li><strong>启动速度</strong>：秒级启动时间</li><li><strong>密度</strong>：单机可运行更多应用实例</li></ul><h4 id="3-可移植性"><a href="#3-可移植性" class="headerlink" title="3. 可移植性"></a>3. 可移植性</h4><ul><li><strong>跨平台</strong>：Linux、Windows、macOS都支持</li><li><strong>云原生</strong>：在各种云平台间迁移</li><li><strong>混合环境</strong>：本地开发，云端部署</li></ul><h4 id="4-版本控制和回滚"><a href="#4-版本控制和回滚" class="headerlink" title="4. 版本控制和回滚"></a>4. 版本控制和回滚</h4><ul><li><strong>镜像版本</strong>：每个版本都有对应的镜像</li><li><strong>快速回滚</strong>：出问题时快速回到上一版本</li><li><strong>A&#x2F;B测试</strong>：同时运行不同版本进行对比</li></ul><h4 id="5-扩展性"><a href="#5-扩展性" class="headerlink" title="5. 扩展性"></a>5. 扩展性</h4><ul><li><strong>水平扩展</strong>：快速创建更多容器实例</li><li><strong>弹性伸缩</strong>：根据负载自动调整容器数量</li><li><strong>微服务</strong>：服务拆分和独立部署</li></ul><h3 id="典型应用场景"><a href="#典型应用场景" class="headerlink" title="典型应用场景"></a>典型应用场景</h3><h4 id="1-微服务架构"><a href="#1-微服务架构" class="headerlink" title="1. 微服务架构"></a>1. 微服务架构</h4><ul><li><strong>服务拆分</strong>：每个微服务独立容器化</li><li><strong>独立部署</strong>：服务可以独立更新和扩展</li><li><strong>技术栈自由</strong>：不同服务可以使用不同技术</li></ul><h4 id="2-CI-CD流水线"><a href="#2-CI-CD流水线" class="headerlink" title="2. CI&#x2F;CD流水线"></a>2. CI&#x2F;CD流水线</h4><ul><li><strong>构建环境</strong>：标准化的构建环境</li><li><strong>测试隔离</strong>：每个测试在独立容器中运行</li><li><strong>部署一致性</strong>：相同镜像在不同环境部署</li></ul><h4 id="3-开发环境标准化"><a href="#3-开发环境标准化" class="headerlink" title="3. 开发环境标准化"></a>3. 开发环境标准化</h4><ul><li><strong>快速搭建</strong>：新成员快速获得开发环境</li><li><strong>版本同步</strong>：团队使用相同的开发环境</li><li><strong>依赖管理</strong>：避免本地环境冲突</li></ul><h4 id="4-应用现代化"><a href="#4-应用现代化" class="headerlink" title="4. 应用现代化"></a>4. 应用现代化</h4><ul><li><strong>遗留系统</strong>：将传统应用容器化</li><li><strong>云迁移</strong>：帮助应用迁移到云平台</li><li><strong>混合云</strong>：在不同云环境间移植</li></ul><h2 id="Docker的发展历史"><a href="#Docker的发展历史" class="headerlink" title="Docker的发展历史"></a>Docker的发展历史</h2><h3 id="关键时间节点"><a href="#关键时间节点" class="headerlink" title="关键时间节点"></a>关键时间节点</h3><ul><li><strong>2013年</strong>：Docker开源发布</li><li><strong>2014年</strong>：Docker 1.0发布，生产环境可用</li><li><strong>2016年</strong>：Docker Swarm发布，内置编排功能</li><li><strong>2017年</strong>：Docker分为CE(社区版)和EE(企业版)</li><li><strong>2019年</strong>：Docker Desktop发布，改善开发者体验</li></ul><h3 id="生态系统发展"><a href="#生态系统发展" class="headerlink" title="生态系统发展"></a>生态系统发展</h3><ul><li><strong>容器编排</strong>：Kubernetes成为事实标准</li><li><strong>容器运行时</strong>：containerd、CRI-O等替代方案</li><li><strong>镜像格式</strong>：OCI标准制定</li><li><strong>安全工具</strong>：容器安全扫描和监控工具</li></ul><h1 id="Docker架构"><a href="#Docker架构" class="headerlink" title="Docker架构"></a>Docker架构</h1><p>Docker 架构是基于客户端-服务器模式的，其中包括多个关键组件，确保容器化应用的高效构建、管理和运行。</p><p>Docker 的架构设计使得开发者能够轻松地将应用程序与其所有依赖封装在一个可移植的容器中，并在不同的环境中一致地运行。</p><p>Docker 使用客户端-服务器 (C&#x2F;S) 架构模式，使用远程 API 来管理和创建 Docker 容器。</p><p>Docker 容器通过 Docker 镜像来创建。</p><p>容器与镜像的关系类似于面向对象编程中的对象与类。</p><table><thead><tr><th align="left">Docker</th><th align="left">面向对象</th></tr></thead><tbody><tr><td align="left">容器</td><td align="left">对象</td></tr><tr><td align="left">镜像</td><td align="left">类</td></tr></tbody></table><h2 id="Docker架构示意图"><a href="#Docker架构示意图" class="headerlink" title="Docker架构示意图"></a>Docker架构示意图</h2><p><img src="/post_image/Docker%E5%AD%A6%E4%B9%A0/Docker%E6%9E%B6%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="Docker架构示意图"></p><h2 id="Docker-架构的工作流程"><a href="#Docker-架构的工作流程" class="headerlink" title="Docker 架构的工作流程"></a>Docker 架构的工作流程</h2><ul><li><strong>构建镜像</strong>：使用 <code>Dockerfile</code> 创建镜像。</li><li><strong>推送镜像到注册表</strong>：将镜像上传到 Docker Hub 或私有注册表中。</li><li><strong>拉取镜像</strong>：通过 <code>docker pull</code> 从注册表中拉取镜像。</li><li><strong>运行容器</strong>：使用镜像创建并启动容器。</li><li><strong>管理容器</strong>：使用 Docker 客户端命令管理正在运行的容器（例如查看日志、停止容器、查看资源使用情况等）。</li><li><strong>网络与存储</strong>：容器之间通过 Docker 网络连接，数据通过 Docker 卷或绑定挂载进行持久化。</li></ul><h2 id="Docker的核心组件及其工作机制"><a href="#Docker的核心组件及其工作机制" class="headerlink" title="Docker的核心组件及其工作机制"></a>Docker的核心组件及其工作机制</h2><h3 id="1、Docker-客户端（Docker-Client）"><a href="#1、Docker-客户端（Docker-Client）" class="headerlink" title="1、Docker 客户端（Docker Client）"></a>1、<strong>Docker 客户端（Docker Client）</strong></h3><p>Docker 客户端是用户与 Docker 守护进程交互的命令行界面（CLI）。它是用户与 Docker 系统的主要交互方式，用户通过 Docker CLI 发出命令，这些命令被发送到 Docker 守护进程，由守护进程执行相应的操作。</p><ul><li><strong>功能</strong>：允许用户使用命令与 Docker 守护进程通信，如创建容器、构建镜像、查看容器状态等。</li><li><strong>交互方式</strong>：Docker 客户端与 Docker 守护进程之间通过 REST API 或 Unix 套接字通信。常用的命令行工具是 <code>docker</code>，通过它，用户可以发出各种 Docker 操作命令。</li></ul><h4 id="常用命令："><a href="#常用命令：" class="headerlink" title="常用命令："></a>常用命令：</h4><ul><li><code>docker run</code>：运行容器。</li><li><code>docker ps</code>：列出正在运行的容器。</li><li><code>docker build</code>：构建 Docker 镜像。</li><li><code>docker exec</code>：在容器中执行命令。</li></ul><h3 id="2、Docker-守护进程（Docker-Daemon）"><a href="#2、Docker-守护进程（Docker-Daemon）" class="headerlink" title="2、Docker 守护进程（Docker Daemon）"></a>2、<strong>Docker 守护进程（Docker Daemon）</strong></h3><p>Docker 守护进程（通常是 <code>dockerd</code>）是 Docker 架构的核心，负责管理容器生命周期、构建镜像、分发镜像等任务。</p><p>守护进程通常以后台进程的方式运行，等待来自 Docker 客户端的 API 请求。</p><p><strong>功能</strong>：</p><ul><li>启动和停止容器。</li><li>构建、拉取和推送镜像。</li><li>管理容器的网络和存储。</li><li>启动、停止、查看容器日志等。</li><li>与 Docker 注册表进行通信，管理镜像的存储与分发。</li></ul><p>Docker 守护进程监听来自 Docker 客户端的请求，并且通过 Docker API 执行这些请求。守护进程将负责容器、镜像等 Docker 对象的管理，并根据请求的参数启动容器、删除容器、修改容器配置等。</p><p>启动 Docker 守护进程（通常是自动启动的）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start docker</span><br></pre></td></tr></table></figure><h3 id="3、Docker-引擎-API（Docker-Engine-API）"><a href="#3、Docker-引擎-API（Docker-Engine-API）" class="headerlink" title="3、Docker 引擎 API（Docker Engine API）"></a>3、<strong>Docker 引擎 API（Docker Engine API）</strong></h3><p>Docker 引擎 API 是 Docker 提供的 RESTful 接口，允许外部客户端与 Docker 守护进程进行通信。通过这个 API，用户可以执行各种操作，如启动容器、构建镜像、查看容器状态等。API 提供了 HTTP 请求的接口，支持跨平台调用。</p><p><strong>功能</strong>：</p><ul><li>向 Docker 守护进程发送 HTTP 请求，实现容器、镜像的管理。</li><li>提供 RESTful 接口，允许通过编程与 Docker 进行交互。</li></ul><p>可以通过 <code>curl</code> 或其他 HTTP 客户端访问 Docker 引擎 API。例如，查询当前 Docker 守护进程的版本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl --unix-socket /var/run/docker.sock http://localhost/version</span><br></pre></td></tr></table></figure><h3 id="4、Docker-容器（Docker-Containers）"><a href="#4、Docker-容器（Docker-Containers）" class="headerlink" title="4、Docker 容器（Docker Containers）"></a>4、<strong>Docker 容器（Docker Containers）</strong></h3><p>容器是 Docker 的执行环境，它是轻量级、独立且可执行的软件包。容器是从 Docker 镜像启动的，包含了运行某个应用程序所需的一切——从操作系统库到应用程序代码。容器在运行时与其他容器和宿主机共享操作系统内核，但容器之间的文件系统和进程是隔离的。</p><p><strong>功能</strong>：</p><ul><li>提供独立的运行环境，确保应用程序在不同的环境中具有一致的行为。</li><li>容器是临时的，通常在任务完成后被销毁。</li></ul><p>容器的生命周期是由 Docker 守护进程管理的。容器可以在任何地方运行，因为它们不依赖于底层操作系统的配置，所有的运行时依赖已经封装在镜像中。</p><p>启动一个容器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d ubuntu</span><br></pre></td></tr></table></figure><h3 id="5、Docker-镜像（Docker-Images）"><a href="#5、Docker-镜像（Docker-Images）" class="headerlink" title="5、Docker 镜像（Docker Images）"></a>5、<strong>Docker 镜像（Docker Images）</strong></h3><p>Docker 镜像是容器的只读模板。每个镜像都包含了应用程序运行所需的操作系统、运行时、库、环境变量和应用代码等。镜像是静态的，用户可以根据镜像启动容器。</p><p><strong>功能</strong>：</p><ul><li>镜像是构建容器的基础，每个容器实例化时都会使用镜像。</li><li>镜像是只读的，不同容器使用同一个镜像时，容器中的文件系统层是独立的。</li></ul><p>Docker 镜像可以通过 <code>docker pull</code> 从 Docker Hub 或私有注册表拉取，也可以通过 <code>docker build</code> 从 Dockerfile 构建。</p><p>拉取 Ubuntu 镜像：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull ubuntu</span><br></pre></td></tr></table></figure><h3 id="6-Docker-仓库（Docker-Registries）"><a href="#6-Docker-仓库（Docker-Registries）" class="headerlink" title="6. Docker 仓库（Docker Registries）"></a>6. <strong>Docker 仓库（Docker Registries）</strong></h3><p>Docker 仓库是用来存储 Docker 镜像的地方，最常用的公共仓库是 <strong>Docker Hub</strong>。用户可以从 Docker Hub 下载镜像，也可以上传自己的镜像分享给其他人。除了公共仓库，用户也可以部署自己的私有 Docker 仓库来管理企业内部的镜像。</p><p><strong>功能</strong>：</p><ul><li>存储 Docker 镜像。</li><li>提供镜像的上传和下载功能。</li></ul><p>Docker Hub 提供了大量官方和社区维护的镜像，如 Ubuntu、Nginx、MySQL 等。</p><p>推送镜像到 Docker Hub：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push &lt;username&gt;/&lt;image_name&gt;</span><br></pre></td></tr></table></figure><h3 id="7、Docker-Compose"><a href="#7、Docker-Compose" class="headerlink" title="7、Docker Compose"></a>7、<strong>Docker Compose</strong></h3><p>Docker Compose 是一个用于定义和运行多容器 Docker 应用的工具。通过 Compose，用户可以使用一个 <code>docker-compose.yml</code> 配置文件定义多个容器（服务），并可以通过一个命令启动这些容器。Docker Compose 主要用于开发、测试和部署多容器的应用。</p><p><strong>功能</strong>：</p><ul><li>定义和运行多个容器组成的应用。</li><li>通过 YAML 文件来配置应用的服务、网络和卷等。</li></ul><p>创建一个简单的 <code>docker-compose.yml</code> 文件来配置一个包含 Web 服务和数据库服务的应用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">version: &#x27;3&#x27;</span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    image: nginx</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;8080:80&quot;</span><br><span class="line">  db:</span><br><span class="line">    image: mysql</span><br><span class="line">    environment:</span><br><span class="line">      MYSQL_ROOT_PASSWORD: example</span><br></pre></td></tr></table></figure><p>启动 Compose 定义的所有服务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up</span><br></pre></td></tr></table></figure><h3 id="8、Docker-Swarm"><a href="#8、Docker-Swarm" class="headerlink" title="8、Docker Swarm"></a>8、<strong>Docker Swarm</strong></h3><p>Docker Swarm 是 Docker 提供的集群管理和调度工具。它允许将多个 Docker 主机（节点）组织成一个集群，并通过 Swarm 集群管理工具来调度和管理容器。Swarm 可以实现容器的负载均衡、高可用性和自动扩展等功能。</p><p><strong>功能</strong>：</p><ul><li>管理多节点 Docker 集群。</li><li>通过调度器管理容器的部署和扩展。</li></ul><p>初始化 Swarm 集群：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker swarm init</span><br></pre></td></tr></table></figure><h3 id="9、Docker-网络（Docker-Networks）"><a href="#9、Docker-网络（Docker-Networks）" class="headerlink" title="9、Docker 网络（Docker Networks）"></a>9、<strong>Docker 网络（Docker Networks）</strong></h3><p>Docker 网络允许容器之间相互通信，并与外部世界进行连接。Docker 提供了多种网络模式来满足不同的需求，如 <code>bridge</code> 网络（默认）、<code>host</code> 网络和 <code>overlay</code> 网络等。</p><p><strong>功能</strong>：</p><ul><li>管理容器间的网络通信。</li><li>支持不同的网络模式，以适应不同场景下的需求。</li></ul><p>创建一个自定义网络并将容器连接到该网络：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker network create my_network</span><br><span class="line">docker run -d --network my_network ubuntu</span><br></pre></td></tr></table></figure><h3 id="10-Docker-卷（Docker-Volumes）"><a href="#10-Docker-卷（Docker-Volumes）" class="headerlink" title="10. Docker 卷（Docker Volumes）"></a>10. <strong>Docker 卷（Docker Volumes）</strong></h3><p>Docker 卷是一种数据持久化机制，允许数据在容器之间共享，并且独立于容器的生命周期。与容器文件系统不同，卷的内容不会随着容器的销毁而丢失，适用于数据库等需要持久存储的应用。</p><p><strong>功能</strong>：</p><ul><li>允许容器间共享数据。</li><li>保证数据持久化，独立于容器的生命周期。</li></ul><p>创建并挂载卷：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker volume create my_volume</span><br><span class="line">docker run -d -v my_volume:/data ubuntu</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Docker学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo + Butterfly 搭建博客教程（）Hexo框架</title>
      <link href="/2025/05/10/Hexo%E6%90%AD%E5%BB%BAblog%E6%95%99%E7%A8%8B/hexo-build-tutorial-2/"/>
      <url>/2025/05/10/Hexo%E6%90%AD%E5%BB%BAblog%E6%95%99%E7%A8%8B/hexo-build-tutorial-2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
      
      
      <categories>
          
          <category> Hexo + Butterfly 搭建博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Hexo-Butterfly-Theme </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL学习-进阶篇(七)MySQL管理</title>
      <link href="/2025/05/10/MySQL%E5%AD%A6%E4%B9%A0/%E8%BF%9B%E9%98%B6(%E4%B8%83)-MySQL%E7%AE%A1%E7%90%86/"/>
      <url>/2025/05/10/MySQL%E5%AD%A6%E4%B9%A0/%E8%BF%9B%E9%98%B6(%E4%B8%83)-MySQL%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="系统数据库"><a href="#系统数据库" class="headerlink" title="系统数据库"></a>系统数据库</h1><p><code>MySQL</code>数据库安装完成后，自带了4个数据库，具体如下：</p><table><thead><tr><th>数据库</th><th>含义</th></tr></thead><tbody><tr><td><code>mysql</code></td><td>存储<code>MySQL</code>服务器正常运行所需要的各种信息（时区、主从、用户、权限等）</td></tr><tr><td><code>information_schema</code></td><td>提供了访问数据库元数据的各种表和视图，包含数据库、表、字段类型及访问权限等</td></tr><tr><td><code>performance_schema</code></td><td>为<code>MySQL</code>服务器运行时状态提供了一个底层监控功能，主要用于收集数据库服务器性能参数</td></tr><tr><td><code>sys</code></td><td>包含了一系列方便DBA和开发人员利用<code>performance_schema</code>性能数据库进行性能调优和诊断的视图</td></tr></tbody></table><hr><h1 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a>常用工具</h1><ul><li><strong>mysql</strong></li></ul><p>该mysql不是指mysql服务，而是指mysql的客户端工具</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--- 语法</span></span><br><span class="line">mysql [options] [database]</span><br><span class="line"><span class="comment">--- 选项</span></span><br><span class="line"><span class="operator">-</span>u, <span class="comment">--user#指定用户名</span></span><br><span class="line"><span class="operator">-</span>p, <span class="comment">--password  #指定密码</span></span><br><span class="line"><span class="operator">-</span>h, <span class="comment">--host  #指定服务器ip或域名</span></span><br><span class="line"><span class="operator">-</span>P, <span class="comment">--port  #指定连接端口</span></span><br><span class="line"><span class="operator">-</span>e, <span class="comment">--execute #执行SQL语句并退出</span></span><br></pre></td></tr></table></figure><p><code>-e</code>选项可以在<code>MySQL</code>客户端执行<code>SQL</code>语句，而不用连接到<code>MySQL</code>数据库再执行，对于一些批处理脚本，这种方式尤其方便。</p><ul><li><strong>mysqladmin</strong></li></ul><p>mysqladmin 是一个执行管理操作的客户端程序。可以用它来检查服务器的配置和当前状态、创建并删除数据库等。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--- 语法</span></span><br><span class="line">mysqladmin [options] [指令]</span><br><span class="line"><span class="comment">--- 选项和指令</span></span><br><span class="line">mysqladmin <span class="comment">--help  #通过帮助文档查看选项和指令</span></span><br></pre></td></tr></table></figure><ul><li><strong>mysqlbinlog</strong></li></ul><p>由于服务器生成的二进制日志文件以二进制格式保存，所以如果想要检查这些文本的文本格式，就会用到mysqlbinlog日志管理工具。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--- 语法</span></span><br><span class="line">mysqlbinlog [options] log<span class="operator">-</span>files1 log<span class="operator">-</span>files2</span><br><span class="line"><span class="comment">--- 选项</span></span><br><span class="line"><span class="operator">-</span>d, <span class="comment">--database#指定数据库名称，只列出指定的数据库相关操作</span></span><br><span class="line"><span class="operator">-</span>o, <span class="comment">--offset#忽略掉日志中的前n行命令</span></span><br><span class="line"><span class="operator">-</span>r, <span class="comment">--result-file#将输出的文本格式日志输出到指定文件</span></span><br><span class="line"><span class="operator">-</span>s, <span class="comment">--short-form#显示简单格式，省略掉一些信息</span></span><br><span class="line"><span class="comment">--start-datetime --stop-datetime#指定日期间隔内的所有日志</span></span><br><span class="line"><span class="comment">--start-position --stop-position#指定日期间隔内的所有日志</span></span><br></pre></td></tr></table></figure><ul><li><strong>mysqlshow</strong></li></ul><p>mysqlshow 客户端对象查找工具，用来很快地查找存在哪些数据库、数据库中的表、表中的列或者索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--- 语法</span></span><br><span class="line">mysqlshow [options] [db_name] [table_name] [clo_name]</span><br><span class="line"><span class="comment">--- 选项</span></span><br><span class="line"><span class="comment">--count#显示数据库及表的统计信息（数据库，表均可以不指定）</span></span><br><span class="line"><span class="operator">-</span>i#显示指定数据库或指定表的状态信息</span><br></pre></td></tr></table></figure><ul><li><strong>mysqldump</strong></li></ul><p>mysqldump 客户端工具用来备份数据库或在不同数据库之间进行数据迁移。备份内容包含创建表，及插入表的SQL语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--- 语法</span></span><br><span class="line">mysqldump [options] db_name [tables]</span><br><span class="line"><span class="comment">--- 连接选项</span></span><br><span class="line"><span class="operator">-</span>u, <span class="comment">--user#指定用户名</span></span><br><span class="line"><span class="operator">-</span>p, <span class="comment">--password#指定密码</span></span><br><span class="line"><span class="operator">-</span>h, <span class="comment">--host#指定服务器ip或域名</span></span><br><span class="line"><span class="operator">-</span>P, <span class="comment">--port#指定连接端口</span></span><br><span class="line"><span class="comment">--- 输出选项</span></span><br><span class="line"><span class="comment">--add-drop-database#在每个数据库创建语句前加上drop database语句</span></span><br><span class="line"><span class="comment">--add-drop-table#在每个表创建语句前加上drop table语句，默认开启</span></span><br><span class="line"><span class="operator">-</span>n, <span class="comment">--no-create-db#不包含数据库的创建语句</span></span><br><span class="line"><span class="operator">-</span>t, <span class="comment">--no-create-info#不包含数据表的创建语句</span></span><br><span class="line"><span class="operator">-</span>d, <span class="comment">--no-data#不包含数据</span></span><br><span class="line"><span class="operator">-</span>T#自动生成两个文件：一个<span class="keyword">sql</span>文件，创建表结构的语句；一个txt文件，数据文件</span><br></pre></td></tr></table></figure><ul><li><strong>mysqlimport&#x2F;source</strong></li></ul><p>mysqlimport是客户端数据导入工具，用来导入mysqldump加-T参数后导出的文本文件。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--- 语法</span></span><br><span class="line">mysqlimport [options] db_name txtfile1 [txtfile2...]</span><br></pre></td></tr></table></figure><p>如果需要导入<code>sql</code>文件，可以使用<code>mysql</code>中的source指令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--- 语法</span></span><br><span class="line">source <span class="operator">/</span>x<span class="operator">/</span>xx<span class="operator">/</span>xxx.sql</span><br></pre></td></tr></table></figure><hr><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ol><li><strong>mysql</strong></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- mysql客户端工具, -e 执行SQL并退出</span></span><br></pre></td></tr></table></figure><ol start="2"><li><strong>mysqladmin</strong></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- mysql管理工具</span></span><br></pre></td></tr></table></figure><ol start="3"><li><strong>mysqlbinlog</strong></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 二进制日志查看工具</span></span><br></pre></td></tr></table></figure><ol start="4"><li><strong>mysqlshow</strong></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看数据库、表、字段的统计信息</span></span><br></pre></td></tr></table></figure><ol start="5"><li><strong>mysqldump</strong></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 数据备份工具</span></span><br></pre></td></tr></table></figure><ol start="6"><li><strong>mysqlimport&#x2F;source</strong></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 数据导入工具</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MySQL学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL学习-进阶篇(六)InnoDB引擎</title>
      <link href="/2025/05/07/MySQL%E5%AD%A6%E4%B9%A0/%E8%BF%9B%E9%98%B6(%E5%85%AD)-InnoDB%E5%BC%95%E6%93%8E/"/>
      <url>/2025/05/07/MySQL%E5%AD%A6%E4%B9%A0/%E8%BF%9B%E9%98%B6(%E5%85%AD)-InnoDB%E5%BC%95%E6%93%8E/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="逻辑存储结构"><a href="#逻辑存储结构" class="headerlink" title="逻辑存储结构"></a>逻辑存储结构</h1><h4 id="🧱-InnoDB-逻辑存储结构层级"><a href="#🧱-InnoDB-逻辑存储结构层级" class="headerlink" title="🧱 InnoDB 逻辑存储结构层级"></a>🧱 <code>InnoDB</code> 逻辑存储结构层级</h4><h4 id="1-表空间（Tablespace）"><a href="#1-表空间（Tablespace）" class="headerlink" title="1. 表空间（Tablespace）"></a>1. <strong>表空间（Tablespace）</strong></h4><ul><li>表空间是 <code>InnoDB</code> 存储数据的最高逻辑结构。</li><li>可以是共享表空间（系统表空间）或独立表空间（每个表一个 <code>.ibd</code> 文件）。</li><li><strong>包含多个段（Segment）</strong>。</li></ul><h4 id="2-段（Segment）"><a href="#2-段（Segment）" class="headerlink" title="2. 段（Segment）"></a>2. <strong>段（Segment）</strong></h4><ul><li>每个表或索引都有自己的段。</li><li>一张表至少包含两个段：<ul><li>数据段（存放行记录）</li><li>索引段（存放索引记录）</li></ul></li><li>段是由多个区（Extent）组成的。</li></ul><h4 id="3-区（Extent）"><a href="#3-区（Extent）" class="headerlink" title="3. 区（Extent）"></a>3. <strong>区（Extent）</strong></h4><ul><li>是 InnoDB 中分配存储空间的基本单位，<strong>每个区大小为 1MB</strong>，包含 <strong>64 个页（Page）</strong>。</li><li>当段空间不足时，会以区为单位进行扩展。</li></ul><h4 id="4-页（Page）"><a href="#4-页（Page）" class="headerlink" title="4. 页（Page）"></a>4. <strong>页（Page）</strong></h4><ul><li>是 InnoDB 存储数据的基本单位，<strong>默认大小为 16KB</strong>。</li><li>常见的页类型：<ul><li>数据页（data page）</li><li>索引页（index page）</li><li>undo 页</li><li>系统页（system page）</li><li>插入缓冲页（insert buffer page）</li><li>事务系统页（transaction system page）</li><li>文件空间头页（file space header page）</li></ul></li></ul><h4 id="5-行（Row）"><a href="#5-行（Row）" class="headerlink" title="5. 行（Row）"></a>5. <strong>行（Row）</strong></h4><ul><li>页中存储的具体数据记录（行）。</li><li>每一页可以存储多条行记录，行记录之间有<strong>指针连接</strong>形成链表。</li></ul><h4 id="🧩-图示结构"><a href="#🧩-图示结构" class="headerlink" title="🧩 图示结构"></a>🧩 图示结构</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">InnoDB 逻辑存储结构层级：</span><br><span class="line"></span><br><span class="line">┌──────────────────────────┐</span><br><span class="line">│      表空间 Tablespace   │</span><br><span class="line">│ ┌──────────────────────┐ │</span><br><span class="line">│ │      段 Segment       │ │</span><br><span class="line">│ │ ┌──────────────────┐ │ │</span><br><span class="line">│ │ │   区 Extent (1MB) │ │ │</span><br><span class="line">│ │ │ ┌──────────────┐ │ │ │</span><br><span class="line">│ │ │ │ 页 Page(16KB) │ │ │ │</span><br><span class="line">│ │ │ │┌────────────┐│ │ │ │</span><br><span class="line">│ │ │ ││  行 Record ││ │ │ │</span><br><span class="line">│ │ │ │└────────────┘│ │ │ │</span><br><span class="line">│ │ │ └──────────────┘ │ │ │</span><br><span class="line">│ │ └──────────────────┘ │ │</span><br><span class="line">│ └──────────────────────┘ │</span><br><span class="line">└──────────────────────────┘</span><br></pre></td></tr></table></figure><hr><h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><p>MySQL5.5版本开始，默认使用<code>InnoDB</code>存储引擎，它擅长事务处理，具有崩溃恢复特性，在日常开发中使用非常广泛。下面是<code>InnoDB</code>架构图，左侧为内存结构，右侧为磁盘结构</p><p><img src="/post_image/MySQL%E5%AD%A6%E4%B9%A0/InnoDB%E6%9E%B6%E6%9E%84.png" alt="InnoDB架构"></p><h4 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a><strong>内存结构</strong></h4><ol><li><strong><code>Buffer Pool</code></strong></li></ol><p>缓冲池是主内存中的一个区域，里面可以缓存磁盘上经常操作的真实数据，在执行增删改查操作时，先操作缓冲池中的数据（若缓冲池没有数据，则从磁盘加载并缓存），然后再以一定频率刷新到磁盘，从而减少磁盘<code>IO</code>，加快处理速度。</p><p>缓冲池以<code>Page</code>页为单位，底层采用链表数据结构管理<code>Page</code>。根据状态，将<code>Pafe</code>分为三种类型：</p><ul><li><code>free page</code>：空闲<code>page</code>，未被使用</li><li><code>clean page</code>：被使用<code>page</code>，数据没有被修改过</li><li><code>dirty page</code>：脏页，被使用<code>page</code>，数据被修改过，页中数据与磁盘的数据产生了不一致</li></ul><ol start="2"><li><strong><code>Change Buffer</code></strong></li></ol><p>更改缓冲区（针对于非唯一二级索引页），在执行<code>DML</code>语句时，如果这些数据<code>Page</code>没有在<code>Buffer Pool</code>中，不会直接操作磁盘，而会将数据变更存在更改缓冲区<code>Change Buffer</code>中，在未来数据被读取时，再将数据合并恢复到<code>Buffer Pool</code>中，再将合并后的数据刷新到磁盘中</p><ul><li><strong><code>Change Buffer</code>的意义</strong></li></ul><p>与聚集索引不同，二级索引通常是非唯一的，并且以相对随机的顺序插入二级索引。同样，删除和更新可能会影响索引树中不相邻的二级索引页，如果每一次都操作磁盘，会造成大量的磁盘<code>IO</code>，有了<code>ChangeBuffer</code>之后，我们可以在缓冲池中进行合并处理，<strong>减少磁盘<code>IO</code></strong></p><ol start="3"><li><strong><code>Adaptive Hash Index</code></strong></li></ol><p>自适应<code>hash</code>索引，用于优化对<code>Buffer Pool</code>数据的查询。<code>InnoDB</code>存储引擎会监控对表上各索引页的查询，如果观察到<code>hash</code>索引可以提升速度，则建立<code>hash</code>索引，称之为自适应<code>hash</code>索引</p><p><strong>自适应哈希索引，无需人工干预，是系统根据情况自动完成</strong></p><p>参数：<code>adaptive_hash_index</code> 默认<code>on</code></p><ol start="4"><li><strong><code>Log Buffer</code></strong></li></ol><p>日志缓冲区，用来保存要写入到磁盘中的<code>log</code>日志数据（<code>redo log</code>、<code>undo log</code>），默认大小为16MB，日志缓冲区的日志会定期刷新到磁盘中。如果需要更新、插入或删除许多行的事务，增加日志缓冲区的大小可以节省磁盘<code>IO</code></p><p>参数：<code>innodb_log_buffer_size</code>：缓冲区大小</p><p>​    <code>innodb_flush_log_at_trx_commit</code>：日志刷新到磁盘时机</p><ul><li>1：日志在每次事务提交时写入并刷新到磁盘</li><li>0：每秒将日志写入并刷新到磁盘一次</li><li>2：日志在每次事务提交后写入，并每秒刷新到磁盘一次</li></ul><h4 id="磁盘结构"><a href="#磁盘结构" class="headerlink" title="磁盘结构"></a>磁盘结构</h4><ol><li><strong><code>System Tablespace</code></strong></li></ol><p>系统表空间是更改缓冲区的存储区域。如果表是在系统表空间而不是每个表文件或通用表空间中创建的，它也可能包含表和索引数据。</p><p>参数：<code>innodb_data_file_path</code></p><ol start="2"><li><strong><code>File-Per-Table Tablespaces</code></strong></li></ol><p>每个表的文件表空间包含单个<code>InnoDB</code>表的数据和索引，并存储在文件系统上的单个数据文件中。</p><p>参数：<code>innodb_file_per_table</code></p><ol start="3"><li><strong><code>General Tablespaces</code></strong></li></ol><p>通用表空间，需要通过<code>create tablespace</code>语法创建通用表空间，在创建表时，可以指定该表空间。</p><ol start="4"><li><strong><code>Undo Tablespaces</code></strong></li></ol><p>撤销表空间，<code>MySQL</code>实例在初始化时会自动创建两个默认的<code>undo</code>表空间（初始大小16M），用于存储<code>undo log</code>日志。</p><ol start="5"><li><strong><code>Temporary Tablespaces</code></strong></li></ol><p><code>InnoDB</code>使用会话临时表空间和全局临时表空间。存储用户创建的临时表等数据。</p><ol start="6"><li><strong><code>Doublewrite Buffer Files</code></strong></li></ol><p>双写缓冲区，<code>InnoDB</code>引擎将数据页从<code>Buffer Pool</code>刷新到磁盘前，先将数据页写入双写缓冲区文件中，便于系统异常时恢复数据。</p><ol start="7"><li><strong><code>Redo Log</code></strong></li></ol><p>重做日志，是用来实现事务的持久性。该日志文件由两部分组成：重做日志缓冲（<code>redo log buffer</code>）以及重做日志文件（<code>redo log</code>），前者是在内存中，后者在磁盘中。当事务提交之后会把所有修改信息都会存到该日志中，用于在刷新脏页到磁盘时，发生错误时，进行数据恢复使用。</p><p>以循环方式写入重做日志文件。</p><h4 id="后台线程"><a href="#后台线程" class="headerlink" title="后台线程"></a>后台线程</h4><p><strong>缓冲——&gt;硬盘</strong></p><ul><li><strong>Master Thread</strong></li></ul><p><strong>核心后台线程</strong>，负责调度其它线程，还负责将缓冲池中的数据异步刷新到磁盘中，保持数据的一致性，还包括脏页的刷新、合并插入缓存、<code>undo</code>页的回收。</p><ul><li><strong>IO Thread</strong></li></ul><p>在<code>InnoDB</code>存储引擎中大量使用了<code>AIO</code>(异步<code>IO</code>)来处理<code>IO</code>请求，这样可以极大地提高数据库的性能，而<code>IO T和read</code>主要负责这些<code>IO</code>请求的回调。</p><table><thead><tr><th align="center">线程类型</th><th align="center">默认个数</th><th align="center">职责</th></tr></thead><tbody><tr><td align="center"><code>Read thread</code></td><td align="center">4</td><td align="center">负责读操作</td></tr><tr><td align="center"><code>Write thread</code></td><td align="center">4</td><td align="center">负责写操作</td></tr><tr><td align="center"><code>Log thread</code></td><td align="center">1</td><td align="center">负责将日志缓冲区刷新到磁盘</td></tr><tr><td align="center"><code>Insert buffer thread</code></td><td align="center">1</td><td align="center">负责将写缓冲区内容刷新到磁盘</td></tr></tbody></table><ul><li><strong>Purge Thread</strong></li></ul><p>主要用于回收事务已经提交了的<code>undo log</code>，在事务提交之后，<code>undo log</code>可能不用了，就用它来回收。</p><ul><li><strong>Page Cleaner Thread</strong></li></ul><p>协助<code>Master Thread</code>刷新脏页到磁盘的线程，它可以减轻<code>Master Thread</code>的工作压力，减少阻塞。</p><hr><h1 id="事务原理"><a href="#事务原理" class="headerlink" title="事务原理"></a>事务原理</h1><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><ul><li><strong>事务</strong></li></ul><p><strong>事务</strong>是一组操作的集合，它是一个<strong>不可分割的工作单位</strong>，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失效。</p><ul><li><strong>特性</strong><ul><li>原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。</li><li>一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态。</li><li>隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。</li><li>持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。</li></ul></li></ul><p><img src="/post_image/MySQL%E5%AD%A6%E4%B9%A0/%E4%BA%8B%E5%8A%A1%E7%89%B9%E6%80%A7.png" alt="事务特性"></p><h4 id="redo-log——保证持久性"><a href="#redo-log——保证持久性" class="headerlink" title="redo log——保证持久性"></a>redo log——保证持久性</h4><p>重做日志，记录的是事务提交时数据页的物理修改，是用来实现事务的持久性。</p><p>该日志文件由两部分组成：重做日志缓冲（<code>redo log buffer</code>）以及重做日志文件（<code>redo log file</code>），前者是在内存中，后者在磁盘中。当事务提交之后会把所有修改信息都存到该日志文件中，用于刷新脏页到磁盘中，发生错误时，进行数据恢复使用。</p><h4 id="undo-log——保证原子性"><a href="#undo-log——保证原子性" class="headerlink" title="undo log——保证原子性"></a>undo log——保证原子性</h4><p>回滚日志，用于记录数据被修改前的信息，作用包含两个：提供回滚和MVCC(多版本并发控制)</p><p><code>undo log</code>和<code>redo log</code>记录物理日志不一样，它是逻辑日志。可以认为当<code>delete</code>一条记录时，<code>undo log</code>会记录一条对应的<code>insert</code>记录，反之亦然，当<code>update</code>一条记录时，它记录一条相反的<code>update</code>记录。当执行<code>rollback</code>时，就可以从<code>undo log</code>中的逻辑记录读取到相应的内容并进行回滚。</p><p><code>undo log</code>销毁：<code>undo log</code>在事务执行时产生，事务提交时，并不会立即删除<code>undo log</code>，因为这些日志可能还用于<code>MVCC</code>。</p><p><code>undo log</code>存储：<code>undo log</code>采用段的方式进行管理和记录，存放在前面介绍的<code>rollback segment</code>回滚段中，内部包含1024个<code>undo log segment</code>。</p><hr><h1 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h1><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><ul><li><strong>当前读</strong></li></ul><p>读取的是记录的最新版本，读取时还要保证其它并发事务不能修改当前记录，会对读取的记录进行加锁。以下情况都是一种当前读。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> ... lock <span class="keyword">in</span> share mode(共享锁)</span><br><span class="line"><span class="keyword">select</span> ... <span class="keyword">for</span> <span class="keyword">update</span></span><br><span class="line"><span class="keyword">update</span></span><br><span class="line"><span class="keyword">insert</span></span><br><span class="line"><span class="keyword">delete</span>(排他锁)</span><br></pre></td></tr></table></figure><ul><li><strong>快照读</strong></li></ul><p>简单的<code>select</code>（不加锁）就是快照读，快照读，读取的是记录数据的可见版本，有可能是历史数据，不加锁，是非阻塞读。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Read Committed：每次<span class="keyword">select</span>，都生成一个快照读</span><br><span class="line">Repeatable Read：开启事务后第一个<span class="keyword">select</span>语句才是快照读的地方</span><br><span class="line">Serializable：快照读会退化为当前读</span><br></pre></td></tr></table></figure><ul><li><strong>MVCC</strong></li></ul><p>全称<code>Multi-Version Concurrency Control</code>，多版本并发控制。指维护一个数据的多个版本，使得读写操作没有冲突，快照读为<code>MySQL</code>实现。</p><p><code>MVCC</code>提供了一个非阻塞读功能。<code>MVCC</code>的具体实现，还需要依赖于数据库记录中的<strong>三个隐式字段、<code>undo log</code>日志、<code>readView</code>。</strong></p><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><ol><li><strong>记录中的隐藏字段</strong></li></ol><table><thead><tr><th>隐藏字段</th><th>含义</th></tr></thead><tbody><tr><td><code>DB_TRX_ID</code></td><td>最近修改事务<code>ID</code>，记录插入这条记录或最后一次修改该记录的事务<code>ID</code></td></tr><tr><td><code>DB_ROLL_PTR</code></td><td>回滚指针，指向这条记录的上一个版本，用于配合<code>undo log</code>，指向上一个版本</td></tr><tr><td><code>DB_ROW_ID</code></td><td>隐藏主键，如果表结构没有指定主键，将会生成该隐藏字段</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">---查看表结构，可以看到隐藏字段</span></span><br><span class="line">ibd2sdi ibd文件名称</span><br></pre></td></tr></table></figure><ol start="2"><li><strong><code>undo log</code></strong></li></ol><p>回滚日志，在<code>insert</code>、<code>update</code>、<code>detele</code>的时候产生的便于数据回滚的日志。</p><p>当<code>insert</code>的时候，产生的<code>undo log</code>日志只在回滚时需要，在事务提交后，可被立即删除。</p><p>而<code>update</code>、<code>delete</code>的时候，产生的<code>undo log</code>日志不仅在回滚时需要，在快照读时也需要，不会立即被删除。</p><ul><li><code>undo log版本链</code></li></ul><p>不同事务或相同事务对同一条记录进行修改，会导致该记录的<code>undo log</code>生成一条记录版本链路，链表的头部是最新的旧纪录，链表尾部是最早的旧纪录。</p><ol start="3"><li><strong><code>readview</code></strong></li></ol><p><code>ReadView</code>(读视图)是<strong>快照读</strong>SQL执行时<code>MVCC</code>提取数据的依据，记录并维护系统当前活跃的事务（未提交的）<code>id</code>。</p><p><code>ReadView</code>中包含了四个核心字段：</p><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td><code>m_ids</code></td><td>当前活跃的事务<code>ID</code>集合</td></tr><tr><td><code>min_trx_id</code></td><td>最小活跃事务<code>ID</code></td></tr><tr><td><code>max_trx_id</code></td><td>预分配事务<code>ID</code>，当前最大事务<code>ID</code>+1，（因为事务<code>ID</code>是自增的）</td></tr><tr><td><code>creator_trx_id</code></td><td><code>Readview</code>创建者的事务<code>ID</code></td></tr></tbody></table><p><img src="/post_image/MySQL%E5%AD%A6%E4%B9%A0/readview.png" alt="readview"></p><p><strong>不同的隔离级别，生成<code>ReadView</code>的时机不同:</strong></p><ul><li><code>read committed</code>：在事务中每一次执行快照读时生成<code>ReadView</code></li><li><code>repeatable read</code>：仅在事务中第一次执行快照读时生成<code>ReadView</code>，后续复用该<code>ReadView</code></li></ul><hr><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><h4 id="逻辑存储结构-1"><a href="#逻辑存储结构-1" class="headerlink" title="逻辑存储结构"></a>逻辑存储结构</h4><ul><li><strong>表空间</strong></li><li><strong>段</strong></li><li><strong>区</strong></li><li><strong>页</strong></li><li><strong>行</strong></li></ul><h4 id="架构-1"><a href="#架构-1" class="headerlink" title="架构"></a>架构</h4><ul><li><strong>内存结构</strong></li><li><strong>磁盘结构</strong></li></ul><h4 id="事务原理-1"><a href="#事务原理-1" class="headerlink" title="事务原理"></a>事务原理</h4><ul><li><strong>原子性</strong>——<code>undo log</code></li><li><strong>持久性</strong>——<code>redo log</code></li><li><strong>一致性</strong>——<code>undo log</code>+<code>redo log</code></li><li><strong>隔离性</strong>——锁+<code>MVCC</code></li></ul><h4 id="MVCC-1"><a href="#MVCC-1" class="headerlink" title="MVCC"></a>MVCC</h4><ul><li><strong>记录隐藏字段</strong></li><li><strong><code>undo log</code>版本链</strong></li><li><strong><code>ReadView</code></strong></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> MySQL学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL学习-进阶篇(五)锁</title>
      <link href="/2025/05/06/MySQL%E5%AD%A6%E4%B9%A0/%E8%BF%9B%E9%98%B6(%E4%BA%94)-%E9%94%81/"/>
      <url>/2025/05/06/MySQL%E5%AD%A6%E4%B9%A0/%E8%BF%9B%E9%98%B6(%E4%BA%94)-%E9%94%81/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p><strong>锁是计算机协调多个进程或线程并发访问某一资源的机制</strong></p><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><p><code>MySQL</code>中的锁，按照锁的粒度分，分为以下三类：</p><ul><li><strong>全局锁</strong>：锁定数据库中的所有表</li><li><strong>表级锁</strong>：每次操作锁住整张表</li><li><strong>行级锁</strong>：每次操作锁住对应的行数据</li></ul><hr><h1 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h1><h4 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h4><p>全局锁就是对整个数据库实例加锁，加锁后整个实例就处于<strong>只读</strong>状态，后续的<code>DML</code>的写语句，<code>DDL</code>语句，已经更新操作的事务提交语句都将被阻塞。</p><p>典型的使用场景是做全库的逻辑备份，对所有的表进行锁定，从而获取一致性视图，保证数据的完整性。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 加全局锁</span></span><br><span class="line">flush tables <span class="keyword">with</span> read lock;</span><br><span class="line"><span class="comment">-- 解全局锁</span></span><br><span class="line">unlock tables;</span><br></pre></td></tr></table></figure><h4 id="一致性数据备份"><a href="#一致性数据备份" class="headerlink" title="一致性数据备份"></a>一致性数据备份</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 加全局锁</span></span><br><span class="line">flush tables <span class="keyword">with</span> read lock;</span><br><span class="line"><span class="comment">-- 数据备份</span></span><br><span class="line">mysqldump <span class="operator">-</span>u root <span class="operator">-</span>p your_password your_db_name <span class="operator">&gt;</span> backup.sql</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 解全局锁</span></span><br><span class="line">unlock tables;</span><br></pre></td></tr></table></figure><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>数据库中加全局锁，存在以下问题：</p><ol><li>如果在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆</li><li>如果在从库上备份，那么在备份期间从库不能执行主库同步过来的二进制日志文件(<code>binlog</code>)，会导致主从延迟</li></ol><p><strong>在<code>InnoDB</code>引擎中，我们可以在备份的是时加上参数<code>--single-transaction</code>参数来完成不加锁的一致性数据备份</strong></p><hr><h1 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h1><h4 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h4><p>表级锁，每次操作锁住整张表。锁定粒度大，发生锁冲突的概率最高，并发度最低。应用在<code>MyISAM</code>、<code>InnoDB</code>、<code>BDB</code>等存储引擎中</p><h4 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h4><p>对于表级锁，主要分为以下三类：</p><ul><li>表锁</li><li>元数据锁(<code>meta data lock,MDL</code>)</li><li>意向锁</li></ul><h4 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h4><ul><li>表<strong>共享读</strong>锁(<code>read lock</code>)–所有客户端都只读</li><li>表<strong>独占写</strong>锁(<code>write lock</code>)      –当前客户端可读可写，其它客户端不可读不可写</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 加锁</span></span><br><span class="line">lock tables 表名... read<span class="operator">/</span>write</span><br><span class="line"><span class="comment">-- 释放锁</span></span><br><span class="line">unlock tables <span class="operator">/</span> 客户端断开连接</span><br></pre></td></tr></table></figure><p><strong>读锁不会阻塞其它客户端的读，但是会阻塞写。写锁既会阻塞其它客户端的读，又会阻塞其它客户端的写。</strong></p><h4 id="元数据锁-meta-data-lock-MDL"><a href="#元数据锁-meta-data-lock-MDL" class="headerlink" title="元数据锁(meta data lock,MDL)"></a>元数据锁(<code>meta data lock,MDL</code>)</h4><p><code>MDL</code>加锁过程是系统自动控制，无需显示使用，在访问一张表的时候会自动加上。</p><p><code>MDL</code>锁主要作用是维护表元数据的数据一致性，在表上有活动事务时，不可以对元数据进行写入操作</p>]]></content>
      
      
      <categories>
          
          <category> MySQL学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL学习-进阶篇(四)视图/存储过程/触发器</title>
      <link href="/2025/05/05/MySQL%E5%AD%A6%E4%B9%A0/%E8%BF%9B%E9%98%B6(%E5%9B%9B)-%E8%A7%86%E5%9B%BE%E2%80%94%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E2%80%94%E8%A7%A6%E5%8F%91%E5%99%A8/"/>
      <url>/2025/05/05/MySQL%E5%AD%A6%E4%B9%A0/%E8%BF%9B%E9%98%B6(%E5%9B%9B)-%E8%A7%86%E5%9B%BE%E2%80%94%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E2%80%94%E8%A7%A6%E5%8F%91%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h1><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>视图(<code>View</code>)是一种虚拟存在的表。视图中的数据并不在数据库中实际存在，行和列数据来自定义视图的查询中使用的表，并且是在使用视图时动态生成的。</p><p>通俗的将，视图只保存了查询的<code>SQL</code>逻辑，不保存查询结果。所以我们在创建视图的时候，主要的工作就落在创建这条<code>SQL</code>查询语句上。</p><h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><ul><li>创建</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> [<span class="keyword">or</span> replace] <span class="keyword">view</span> 视图名称 <span class="keyword">as</span> <span class="keyword">select</span>语句 [<span class="keyword">with</span> [<span class="keyword">cascaded</span> <span class="operator">|</span> <span class="keyword">local</span>] <span class="keyword">check</span> option]</span><br></pre></td></tr></table></figure><ul><li>查询</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">查看创建视图语句：<span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">view</span> 视图名称;</span><br><span class="line">查看视图数据：<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 视图名称;</span><br></pre></td></tr></table></figure><ul><li>修改</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">方式一：<span class="keyword">create</span> [<span class="keyword">or</span> replace] <span class="keyword">view</span> 视图名称 <span class="keyword">as</span> <span class="keyword">select</span>语句 [<span class="keyword">with</span> [<span class="keyword">cascaded</span> <span class="operator">|</span> <span class="keyword">local</span>] <span class="keyword">check</span> option]</span><br><span class="line">方式二：<span class="keyword">alter</span> <span class="keyword">view</span> 视图名称 <span class="keyword">as</span> <span class="keyword">select</span>语句 [<span class="keyword">with</span> [<span class="keyword">cascaded</span> <span class="operator">|</span> <span class="keyword">local</span>] <span class="keyword">check</span> option]</span><br></pre></td></tr></table></figure><ul><li>删除</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">view</span> [if <span class="keyword">exists</span>] 视图名称</span><br></pre></td></tr></table></figure><h4 id="检查选项"><a href="#检查选项" class="headerlink" title="检查选项"></a>检查选项</h4><ul><li><code>cascaded</code></li></ul><p><strong><code>WITH CHECK OPTION CASCADED</code></strong>：任何通过该视图（或其子视图）执行的 <code>INSERT</code> 或 <code>UPDATE</code> 必须同时满足该视图自身及所有上游视图的 <code>WHERE</code> 条件。检查选项会传递。</p><ul><li><code>local</code></li></ul><p><strong><code>WITH CHECK OPTION LOCAL</code></strong>：仅在当前视图定义的 <code>WHERE</code> 范围内验证，不会向上检查父级视图。检查选项不传递。</p><h4 id="更新及作用"><a href="#更新及作用" class="headerlink" title="更新及作用"></a>更新及作用</h4><ul><li><strong>视图的更新</strong></li></ul><p>要使视图可更新，视图中的行与基础表中的行之间必须存在一对一的关系。如果视图包含以下任何一项，则该视图不可更新：</p><ol><li>聚合函数或窗口函数（<code>SUM()</code>、<code>MIN()</code>、<code>MAX()</code>、<code>COUNT()</code>等）</li><li><code>distinct</code></li><li><code>group by</code></li><li><code>having</code></li><li><code>union</code>或者<code>union all</code></li></ol><ul><li><p><strong>视图的作用</strong></p><ul><li>简单</li></ul><p>视图不仅可以简化用户对数据的理解，也可以简化他们的操作。那些被经常使用的查询可以被定义为视图，从而使得用户不必为以后得操作每次指定全部的条件。</p><ul><li>安全</li></ul><p>数据库可以授权，但不能授权到数据库特定行和特定的列上。通过视图用户只能查询和修改他们所能见到的数据。</p><ul><li>数据独立</li></ul><p>视图可帮助用户屏蔽真实表结构变化带来的影响。</p></li></ul><hr><h1 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h1><h4 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h4><p>存储过程时事先经过编译并存储在数据库中的一段<code>SQL</code>语句的集合，调用存储过程可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的。</p><p>存储过程思想上很简单，就是数据库<code>SQL</code>语言层面的代码封装和重用。</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>封装，复用</li><li>可以接收参数，也可以返回数据</li><li>减少网络交互，效率提升</li></ul><h4 id="基本语法-1"><a href="#基本语法-1" class="headerlink" title="基本语法"></a>基本语法</h4><ul><li>创建</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> 存储过程名称([参数列表])</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">SQL</span>语句;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><ul><li>调用</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">call</span> 名称([参数]);</span><br></pre></td></tr></table></figure><ul><li>查看</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.routines <span class="keyword">where</span> routine_schema<span class="operator">=</span><span class="string">&#x27;xxx&#x27;</span>;<span class="comment">---查询指定数据库的存储过程及状态信息</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">procedure</span> 存储过程名称;<span class="comment">---查询某个存储过程的定义</span></span><br></pre></td></tr></table></figure><ul><li>删除</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">procedure</span> [if <span class="keyword">exists</span>] 存储过程名称;</span><br></pre></td></tr></table></figure><p><strong>注意：由于MySQL默认<code>;</code>为语句结束，所以在命令行执行创建存储过程的<code>SQL</code>时，需要通过关键字<code>delimiter</code>指定<code>SQL</code>语句的结束符。</strong></p><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><ul><li><strong>系统变量</strong></li></ul><p><strong>系统变量</strong>是<code>MySQL</code>服务器提供，不是用户定义的，属于服务器层面。分为全局变量(<strong>GLOBAL</strong>)、会话变量(<strong>SESSION</strong>)。</p><ol><li><strong>查看系统变量</strong></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> [session<span class="operator">|</span><span class="keyword">global</span>] variables;<span class="comment">---查看所有系统变量</span></span><br><span class="line"><span class="keyword">show</span> [session<span class="operator">|</span><span class="keyword">global</span>] variables <span class="keyword">like</span> <span class="string">&#x27;...&#x27;</span><span class="comment">---可以通过like模糊匹配方式查找变量</span></span><br><span class="line"><span class="keyword">select</span> @@[session<span class="operator">|</span><span class="keyword">global</span>] 系统变量名;<span class="comment">---查看指定变量的值</span></span><br></pre></td></tr></table></figure><ol start="2"><li><strong>设置系统变量</strong></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> [session<span class="operator">|</span><span class="keyword">global</span>] 系统变量名<span class="operator">=</span>值;</span><br><span class="line"><span class="keyword">set</span> @@[session<span class="operator">|</span><span class="keyword">global</span>] 系统变量名<span class="operator">=</span>值;</span><br></pre></td></tr></table></figure><ul><li><strong>用户定义变量</strong></li></ul><p><strong>用户定义变量</strong>是用户根据需要自己定义的变量，用户变量不用提前声明，在用的时候直接用“@变量名”使用就可以。其作用域为当前连接。</p><ol><li><strong>赋值</strong></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="variable">@var_name</span> <span class="operator">=</span> expr;</span><br><span class="line"><span class="keyword">set</span> <span class="variable">@var_name</span> :<span class="operator">=</span> expr;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="variable">@var_name</span> :<span class="operator">=</span> expr;</span><br><span class="line"><span class="keyword">select</span> 字段名 <span class="keyword">into</span> <span class="variable">@var_name</span> <span class="keyword">from</span> 表名;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>使用</strong></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="variable">@var_name</span>;</span><br></pre></td></tr></table></figure><p><strong>注意：用户定义的变量无需对其进行声明或初始化，只不过获取到的值为<code>NULL</code></strong></p><ul><li><strong>局部变量</strong></li></ul><p><strong>局部变量</strong>是根据需要定义的在局部生效的变量，访问之前，需要<code>DECLARE</code>声明。可用作存储过程内的局部变量和输入参数，局部变量的范围是在其内声明的<code>BEGIN ... END</code>块。</p><ol><li><strong>声明</strong></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> 变量名 变量类型[<span class="keyword">default</span> ...];</span><br></pre></td></tr></table></figure><p>变量类型就是数据库字段类型：<code>int</code>、<code>bigint</code>、<code>varchar</code>、<code>date</code>、<code>time</code>等</p><ol start="2"><li><strong>赋值</strong></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> 变量名 <span class="operator">=</span> 值;</span><br><span class="line"><span class="keyword">set</span> 变量名 :<span class="operator">=</span> 值;</span><br><span class="line"><span class="keyword">select</span> 字段名 <span class="keyword">into</span> 变量名 <span class="keyword">from</span> 表名;</span><br></pre></td></tr></table></figure><h4 id="if判断"><a href="#if判断" class="headerlink" title="if判断"></a><code>if</code>判断</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> test()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">declare</span> score <span class="type">int</span> <span class="keyword">default</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">declare</span> <span class="keyword">result</span> <span class="type">char</span>(<span class="number">20</span>);</span><br><span class="line">    if score <span class="operator">&gt;=</span> <span class="number">90</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">set</span> <span class="keyword">result</span> <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    elseif score <span class="operator">&gt;=</span> <span class="number">80</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">set</span> <span class="keyword">result</span> <span class="operator">=</span> <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">set</span> <span class="keyword">result</span> <span class="operator">=</span> <span class="string">&#x27;C&#x27;</span>;</span><br><span class="line">    <span class="keyword">end</span> if;</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">result</span> <span class="keyword">into</span> <span class="variable">@result</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> p4();</span><br><span class="line"><span class="keyword">select</span> <span class="variable">@result</span>;</span><br></pre></td></tr></table></figure><h4 id="参数-IN-OUT-INOUT"><a href="#参数-IN-OUT-INOUT" class="headerlink" title="参数(IN,OUT,INOUT)"></a>参数(<code>IN</code>,<code>OUT</code>,<code>INOUT</code>)</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> test(<span class="keyword">in</span> score <span class="type">int</span>,<span class="keyword">out</span> <span class="keyword">result</span> <span class="type">varchar</span>(<span class="number">20</span>))</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"></span><br><span class="line">    if score <span class="operator">&gt;=</span> <span class="number">90</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">set</span> <span class="keyword">result</span> <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    elseif score <span class="operator">&gt;=</span> <span class="number">80</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">set</span> <span class="keyword">result</span> <span class="operator">=</span> <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">set</span> <span class="keyword">result</span> <span class="operator">=</span> <span class="string">&#x27;C&#x27;</span>;</span><br><span class="line">    <span class="keyword">end</span> if;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> test(<span class="number">85</span>, <span class="variable">@grade</span>);</span><br><span class="line"><span class="keyword">select</span> <span class="variable">@grade</span>;</span><br></pre></td></tr></table></figure><h4 id="case"><a href="#case" class="headerlink" title="case"></a><code>case</code></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> test(<span class="keyword">in</span> <span class="keyword">month</span> <span class="type">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">declare</span> <span class="keyword">result</span> <span class="type">varchar</span>(<span class="number">100</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">case</span></span><br><span class="line">        <span class="keyword">when</span> <span class="keyword">month</span> <span class="operator">&gt;=</span> <span class="number">1</span> <span class="keyword">and</span> <span class="keyword">month</span> <span class="operator">&lt;=</span> <span class="number">3</span> <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">set</span> <span class="keyword">result</span> <span class="operator">=</span> <span class="string">&#x27;Q1&#x27;</span>;</span><br><span class="line">        <span class="keyword">when</span> <span class="keyword">month</span> <span class="operator">&gt;=</span> <span class="number">4</span> <span class="keyword">and</span> <span class="keyword">month</span> <span class="operator">&lt;=</span> <span class="number">6</span> <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">set</span> <span class="keyword">result</span> <span class="operator">=</span> <span class="string">&#x27;Q2&#x27;</span>;</span><br><span class="line">        <span class="keyword">when</span> <span class="keyword">month</span> <span class="operator">&gt;=</span> <span class="number">7</span> <span class="keyword">and</span> <span class="keyword">month</span> <span class="operator">&lt;=</span> <span class="number">9</span> <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">set</span> <span class="keyword">result</span> <span class="operator">=</span> <span class="string">&#x27;Q3&#x27;</span>;</span><br><span class="line">        <span class="keyword">when</span> <span class="keyword">month</span> <span class="operator">&gt;=</span> <span class="number">10</span> <span class="keyword">and</span> <span class="keyword">month</span> <span class="operator">&lt;=</span> <span class="number">12</span> <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">set</span> <span class="keyword">result</span> <span class="operator">=</span> <span class="string">&#x27;Q4&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">set</span> <span class="keyword">result</span> <span class="operator">=</span> <span class="string">&#x27;Invalid Month&#x27;</span>;</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">case</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">select</span> concat(<span class="string">&#x27;input month: &#x27;</span>, <span class="keyword">month</span>, <span class="string">&#x27;, quarter: &#x27;</span>, <span class="keyword">result</span>) <span class="keyword">as</span> output;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">call</span> test(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><h4 id="循环-while-repeat-loop"><a href="#循环-while-repeat-loop" class="headerlink" title="循环(while,repeat,loop)"></a>循环(<code>while</code>,<code>repeat</code>,<code>loop</code>)</h4><ul><li><strong><code>while</code></strong></li></ul><p>满足条件执行循环</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> test(<span class="keyword">in</span> n <span class="type">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">declare</span> sum <span class="type">int</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    while n <span class="operator">&gt;</span> <span class="number">0</span> do</span><br><span class="line">        <span class="keyword">set</span> sum <span class="operator">=</span> n <span class="operator">+</span> sum;</span><br><span class="line">        <span class="keyword">set</span> n <span class="operator">=</span> n <span class="operator">-</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span> while;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">select</span> sum;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">call</span> test(<span class="number">10</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong><code>repeat</code></strong></li></ul><p>满足条件退出循环，会先执行一次</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> test(<span class="keyword">in</span> n <span class="type">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">declare</span> sum <span class="type">int</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    repeat</span><br><span class="line">        <span class="keyword">set</span> sum <span class="operator">=</span> sum <span class="operator">+</span> n;</span><br><span class="line">        <span class="keyword">set</span> n <span class="operator">=</span> n <span class="operator">-</span> <span class="number">1</span>;</span><br><span class="line">    until n <span class="operator">&lt;=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">end</span> repeat;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">select</span> sum;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> test(<span class="number">10</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong><code>loop</code></strong></li></ul><p><code>loop</code>实现简单的循环，如果不在<code>SQL</code>逻辑中增加退出循环的条件，可以用其来实现简单的死循环。<code>loop</code>可以配合以下两个语句使用：</p><ol><li><code>leave</code>:配合循环使用，退出循环。</li><li><code>iterate</code>:必须用在循环中，作用是跳过当前循环剩下的语句，直接进入下一次循环。</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> test(<span class="keyword">in</span> n <span class="type">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">declare</span> sum <span class="type">int</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    sum_loop:loop</span><br><span class="line">        if n <span class="operator">&lt;=</span> <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">            leave sum_loop;</span><br><span class="line">        <span class="keyword">end</span> if;</span><br><span class="line">        <span class="keyword">set</span> sum <span class="operator">=</span> sum <span class="operator">+</span> n;</span><br><span class="line">        <span class="keyword">set</span> n <span class="operator">=</span> n <span class="operator">-</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span> loop sum_loop;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">select</span> sum;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> test(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> test(<span class="keyword">in</span> n <span class="type">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">declare</span> sum <span class="type">int</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    sum_loop:loop</span><br><span class="line">        if n <span class="operator">&lt;=</span> <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">            leave sum_loop;</span><br><span class="line">        <span class="keyword">end</span> if;</span><br><span class="line">        if n mod <span class="number">2</span> <span class="operator">=</span> <span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">set</span> n <span class="operator">=</span> n <span class="operator">-</span> <span class="number">1</span>;</span><br><span class="line">            iterate sum_loop;</span><br><span class="line">        <span class="keyword">end</span> if;</span><br><span class="line">        <span class="keyword">set</span> sum <span class="operator">=</span> sum <span class="operator">+</span> n;</span><br><span class="line">        <span class="keyword">set</span> n <span class="operator">=</span> n <span class="operator">-</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span> loop sum_loop;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">select</span> sum;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> test(<span class="number">10</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="游标-cursor"><a href="#游标-cursor" class="headerlink" title="游标(cursor)"></a>游标(<code>cursor</code>)</h4><p>**游标(<code>cursor</code>)**是用来存储查询结果集的数据类型，在存储过程和函数中可以使用游标对结果集进行循环的处理。游标的使用包括游标的声明、<code>OPEN</code>、<code>FETCH</code>和<code>CLOSE</code>，其语法分别如下</p><ul><li><strong>声明游标</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> 游标名称 <span class="keyword">cursor</span> <span class="keyword">for</span> 查询语句;</span><br></pre></td></tr></table></figure><ul><li><strong>打开游标</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> 游标名称</span><br></pre></td></tr></table></figure><ul><li><strong>获取游标记录</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fetch</span> 游标名称 <span class="keyword">into</span> 变量;</span><br></pre></td></tr></table></figure><ul><li><strong>关闭游标</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">close</span> 游标名称</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 游标</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> test(<span class="keyword">in</span> uage <span class="type">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">declare</span> v_name <span class="type">varchar</span>(<span class="number">50</span>);</span><br><span class="line">    <span class="keyword">declare</span> v_email <span class="type">varchar</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="comment">-- 声明游标需要在常规声明之后</span></span><br><span class="line">    <span class="keyword">declare</span> u_cursor <span class="keyword">cursor</span> <span class="keyword">for</span></span><br><span class="line">        <span class="keyword">select</span> name,email <span class="keyword">from</span> customers <span class="keyword">where</span> age <span class="operator">&lt;=</span> uage;</span><br><span class="line">    <span class="comment">-- 声明游标的异常处理</span></span><br><span class="line">    <span class="keyword">declare</span> exit handler <span class="keyword">for</span> <span class="keyword">SQLSTATE</span> <span class="string">&#x27;02000&#x27;</span> <span class="keyword">close</span> u_cursor;</span><br><span class="line">    <span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> test_table;</span><br><span class="line">    <span class="keyword">create table</span> if <span class="keyword">not</span> <span class="keyword">exists</span> test_table(</span><br><span class="line">        id <span class="type">int</span> auto_increment <span class="keyword">primary key</span>,</span><br><span class="line">        name <span class="type">varchar</span>(<span class="number">50</span>),</span><br><span class="line">        email <span class="type">varchar</span>(<span class="number">100</span>)</span><br><span class="line">                                         );</span><br><span class="line">    <span class="keyword">open</span> u_cursor;</span><br><span class="line">    while <span class="literal">true</span> do</span><br><span class="line">        <span class="keyword">fetch</span> u_cursor <span class="keyword">into</span> v_name,v_email;</span><br><span class="line">        <span class="keyword">insert into</span> test_table <span class="keyword">values</span>(<span class="keyword">null</span>,v_name,v_email);</span><br><span class="line">    <span class="keyword">end</span> while;</span><br><span class="line">    <span class="keyword">close</span> u_cursor;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">call</span> test(<span class="number">50</span>);</span><br></pre></td></tr></table></figure><h4 id="条件处理程序-Handler"><a href="#条件处理程序-Handler" class="headerlink" title="条件处理程序(Handler)"></a>条件处理程序(<code>Handler</code>)</h4><p>**条件处理程序（<code>Handler</code>）**可以用来定义在流程控制结构执行过程中遇到问题时相应的处理步骤。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 基本通用格式：</span></span><br><span class="line"><span class="keyword">DECLARE</span></span><br><span class="line">    handler_type HANDLER</span><br><span class="line">    <span class="keyword">FOR</span> condition_value [, condition_value …]</span><br><span class="line">    statement_block;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 其中：</span></span><br><span class="line"><span class="comment">--    handler_type    指定处理程序类型，可以是：</span></span><br><span class="line"><span class="comment">--        CONTINUE  ：遇到指定条件后，“吞掉”错误，继续执行后续语句。</span></span><br><span class="line"><span class="comment">--        EXIT      ：遇到指定条件后，执行 handler 代码块后跳出当前存储程序块（终止）。 </span></span><br><span class="line"><span class="comment">--        UNDO      ：仅在存储函数中有效，遇到指定条件时回滚并离开函数。</span></span><br><span class="line"><span class="comment">--</span></span><br><span class="line"><span class="comment">--    condition_value 指定要捕捉的条件，可为：</span></span><br><span class="line"><span class="comment">--        SQLSTATE &#x27;xxxxxx&#x27;       ：指定 SQLSTATE 代码，如 &#x27;02000&#x27;、&#x27;23000&#x27; 等。</span></span><br><span class="line"><span class="comment">--        SQLWARNING              ：所有 SQLSTATE 为 &#x27;01xxx&#x27; 的警告。</span></span><br><span class="line"><span class="comment">--        NOT FOUND               ：等价于 SQLSTATE &#x27;02000&#x27;（常用于游标处理）。</span></span><br><span class="line"><span class="comment">--        SQLEXCEPTION            ：所有 SQLSTATE 以 &#x27;02xxx&#x27;/ &#x27;07xxx&#x27;/ &#x27;20xxx&#x27;/ &#x27;21xxx&#x27;/ &#x27;22xxx&#x27;/ &#x27;23xxx&#x27;/ &#x27;40xxx&#x27;/ &#x27;HY000&#x27; 等统称异常。</span></span><br><span class="line"><span class="comment">--        MySQL error_code（数字）：例如 1062（主键冲突）、1048（列不允许为空）等。</span></span><br><span class="line"><span class="comment">--    statement_block 处理程序执行的单条语句或复合语句块（BEGIN … END）。</span></span><br></pre></td></tr></table></figure><h4 id="存储函数"><a href="#存储函数" class="headerlink" title="存储函数"></a>存储函数</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> 存储函数名称([参数列表])</span><br><span class="line"><span class="keyword">returns</span> type [characteristic...]</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">SQL</span>语句;</span><br><span class="line">return...;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line">characteristic说明：</span><br><span class="line"><span class="operator">-</span> <span class="keyword">deterministic</span>：相同的输入参数总是产生相同的结果</span><br><span class="line"><span class="operator">-</span> <span class="keyword">no</span> <span class="keyword">sql</span>：不包含<span class="keyword">SQL</span>语句</span><br><span class="line"><span class="operator">-</span> <span class="keyword">reads</span> <span class="keyword">sql</span> data：包含读取数据的语句，但不包含写入数据的语句</span><br></pre></td></tr></table></figure><hr><h1 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h1><h4 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h4><p>**触发器（Trigger）**是一种在数据库中自动执行的对象，当对表进行 <strong>INSERT&#x2F;UPDATE&#x2F;DELETE</strong> 操作时，触发器会在指定时机被自动激活并执行相应逻辑。使用触发器可以实现数据完整性约束、审计日志、自动同步等功能。<strong>行级触发器</strong></p><hr><p><strong>1. 基本概念</strong></p><ul><li><p><strong>触发时机（Timing）</strong>  </p><ul><li><code>BEFORE</code>：在事件操作发生之前执行  </li><li><code>AFTER</code>：在事件操作发生之后执行</li></ul></li><li><p><strong>触发事件（Event）</strong>  </p><ul><li><code>INSERT</code>：插入新行时触发  </li><li><code>UPDATE</code>：更新已有行时触发  </li><li><code>DELETE</code>：删除行时触发</li></ul></li><li><p><strong>触发对象（Table）</strong><br>触发器总是与某个表（或视图）绑定，当对该表执行指定事件时，触发器自动生效。</p></li><li><p><strong>OLD 与 NEW</strong>  </p><ul><li>对于 <code>INSERT</code>：只能访问 <code>NEW</code>（新插入行的各列值）  </li><li>对于 <code>DELETE</code>：只能访问 <code>OLD</code>（被删除行的各列值）  </li><li>对于 <code>UPDATE</code>：既可访问 <code>OLD</code>（更新前的值），又可访问 <code>NEW</code>（更新后的值）</li></ul></li></ul><hr><ol start="2"><li><strong>创建</strong></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER $$</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> trigger_name</span><br><span class="line">  &#123;BEFORE <span class="operator">|</span> AFTER&#125; &#123;<span class="keyword">INSERT</span> <span class="operator">|</span> <span class="keyword">UPDATE</span> <span class="operator">|</span> <span class="keyword">DELETE</span>&#125;</span><br><span class="line">  <span class="keyword">on</span> tabl_name</span><br><span class="line">  <span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span></span><br><span class="line">  [FOLLOWS <span class="operator">|</span> <span class="keyword">PRECEDES</span> other_trigger_name]  <span class="comment">-- 可选，定义同表同事件触发器执行顺序</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="comment">-- 业务逻辑或 SQL 语句块</span></span><br><span class="line"><span class="keyword">end</span> $$</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>查看</strong></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> triggers;</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>删除</strong></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">trigger</span> [schema_name] trigger_name;<span class="operator">-</span>如果没有指定`schema_name`,默认为当前数据库</span><br></pre></td></tr></table></figure><h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><ul><li><strong><code>insert</code></strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 插入数据触发器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> insert_trig</span><br><span class="line">after <span class="keyword">insert</span> <span class="keyword">on</span> customers</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">insert into</span> log_table (action, customer_id, action_time, operate_params)</span><br><span class="line">  <span class="keyword">values</span> (<span class="string">&#x27;insert&#x27;</span>, new.id, now(),</span><br><span class="line">          concat(<span class="string">&#x27;插入的数据：id: &#x27;</span>, new.id, <span class="string">&#x27;, name: &#x27;</span>, new.name, <span class="string">&#x27;, email: &#x27;</span>, new.email));</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><ul><li><strong><code>update</code></strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 更新数据触发器</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> update_trig</span><br><span class="line">after <span class="keyword">update</span> <span class="keyword">on</span> customers</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">insert into</span> log_table (action, customer_id, action_time,</span><br><span class="line">          operate_params)</span><br><span class="line">  <span class="keyword">values</span> (<span class="string">&#x27;update&#x27;</span>, new.id, now(),</span><br><span class="line">          concat(<span class="string">&#x27;更新前的数据：id: &#x27;</span>, old.id, <span class="string">&#x27;, name: &#x27;</span>, old.name, <span class="string">&#x27;, email: &#x27;</span>, old.email,</span><br><span class="line">                 <span class="string">&#x27;; 更新后的数据：id: &#x27;</span>, new.id, <span class="string">&#x27;, name: &#x27;</span>, new.name, <span class="string">&#x27;, email: &#x27;</span>, new.email));</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><ul><li><strong><code>delete</code></strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 删除数据触发器</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> delete_trig</span><br><span class="line">after <span class="keyword">delete</span> <span class="keyword">on</span> customers</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">insert into</span> log_table (action, customer_id, action_time,</span><br><span class="line">          operate_params)</span><br><span class="line">  <span class="keyword">values</span> (<span class="string">&#x27;delete&#x27;</span>, old.id, now(),</span><br><span class="line">          concat(<span class="string">&#x27;删除的数据：id: &#x27;</span>, old.id, <span class="string">&#x27;, name: &#x27;</span>, old.name, <span class="string">&#x27;, email: &#x27;</span>, old.email));</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><hr><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ul><li><strong>视图(<code>view</code>)</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 虚拟存在的表，不保存查询结果，只保存查询的SQL逻辑</span></span><br><span class="line"><span class="comment">-- 简单、安全、数据独立</span></span><br></pre></td></tr></table></figure><ul><li><strong>存储过程(<code>procedure</code>)</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 事先定义并存储在数据库中的一段SQL语句的集合</span></span><br><span class="line"><span class="comment">-- 减少网络交互，提高性能、封装重用</span></span><br><span class="line"><span class="comment">-- 变量、if、case、参数(in/out/inout)、while、repeat、loop、cursor、handler</span></span><br></pre></td></tr></table></figure><ul><li><strong>存储函数(<code>function</code>)</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 存储函数是有返回值的存储过程，参数类型只能为in类型</span></span><br><span class="line"><span class="comment">-- 存储函数可以被存储过程替代</span></span><br></pre></td></tr></table></figure><ul><li><strong>触发器(<code>trigger</code>)</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 可以在表数据进行insert、update、delete之前或之后触发</span></span><br><span class="line"><span class="comment">-- 保证数据完整性、日志记录、数据校验</span></span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> MySQL学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL学习-进阶篇(三)SQL优化</title>
      <link href="/2025/05/01/MySQL%E5%AD%A6%E4%B9%A0/%E8%BF%9B%E9%98%B6(%E4%B8%89)-SQL%E4%BC%98%E5%8C%96/"/>
      <url>/2025/05/01/MySQL%E5%AD%A6%E4%B9%A0/%E8%BF%9B%E9%98%B6(%E4%B8%89)-SQL%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h1><h4 id="1-插入数据"><a href="#1-插入数据" class="headerlink" title="1. 插入数据"></a><strong>1. 插入数据</strong></h4><ul><li><p><strong>insert优化</strong></p><ul><li>批量插入</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert into</span> tb_test <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;Tom&#x27;</span>),(<span class="number">2</span>,<span class="string">&#x27;Cat&#x27;</span>),(<span class="number">3</span>,<span class="string">&#x27;Jerry&#x27;</span>);</span><br></pre></td></tr></table></figure><ul><li>手动提交事务</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">start</span> transaction;</span><br><span class="line"><span class="keyword">insert</span> ....</span><br><span class="line">....</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure><ul><li>主键顺序插入</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 主键乱序插入：<span class="number">8</span><span class="number">1</span><span class="number">9</span><span class="number">21</span><span class="number">88</span><span class="number">2</span><span class="number">4</span><span class="number">15</span><span class="number">89</span><span class="number">5</span><span class="number">7</span><span class="number">3</span></span><br><span class="line"># 主键顺序插入：<span class="number">1</span><span class="number">2</span><span class="number">3</span><span class="number">4</span><span class="number">5</span><span class="number">7</span><span class="number">8</span><span class="number">9</span><span class="number">15</span><span class="number">21</span><span class="number">88</span><span class="number">89</span></span><br></pre></td></tr></table></figure></li><li><p><strong>大批量插入数据</strong></p></li></ul><p>如果一次性需要插入大批量数据，使用<code>insert</code>语句插入性能较低，此时可以使用<code>MySQL</code>数据库提供的**<code>load</code>**指令进行插入.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#客户端连接服务端时，加上参数 <span class="comment">--local-infile</span></span><br><span class="line">mysql <span class="comment">--local-infile -u root -p</span></span><br><span class="line">#设置全局参数local_infile为<span class="number">1</span>，开启从本地加载文件导入数据的开关</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> local_infile <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">#执行load指定将准备好的数据，加载到表结构中</span><br><span class="line">load data <span class="keyword">local</span> infile <span class="string">&#x27;/root/sql1.log&#x27;</span> <span class="keyword">into</span> <span class="keyword">table</span> <span class="string">&#x27;table_name&#x27;</span> fields terminated <span class="keyword">by</span> <span class="string">&#x27;,&#x27;</span> lines terminated <span class="keyword">by</span> <span class="string">&#x27;\n&#x27;</span>;</span><br></pre></td></tr></table></figure><h4 id="2-主键优化"><a href="#2-主键优化" class="headerlink" title="2. 主键优化"></a>2. 主键优化</h4><ul><li><strong>数据组织方式</strong></li></ul><p>在<code>InnoDB</code>存储引擎中，表数据都是根据主键顺序组织存放的，这种存储方式的表称为<strong>索引组织表</strong>(index organized table <strong>IOT</strong>)</p><p><img src="/post_image/MySQL%E5%AD%A6%E4%B9%A0/%E9%80%BB%E8%BE%91%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png" alt="逻辑存储结构"></p><ul><li><strong>页分裂</strong></li></ul><p>页可以为空，也可以填充一半，也可以填充100%。每个页包含了2-N行数据（如果一行数据多大，会行溢出），根据主键排列。</p><ul><li><strong>页合并</strong></li></ul><p>当删除一行记录时，实际上记录并没有被物理删除，只是记录被标记(flaged)为删除并且它的空间变得允许被其他记录声明使用。</p><p>当页中删除的记录达到<code>MERGE_THRESHOLD</code>(默认为页的50%)，<code>InnoDB</code>会开始寻找最靠近的页（前或后）看看是否可以将两个页合并以优化空间使用。</p><p><strong><code>MERGE_THRESHOLD</code></strong>:合并页的阈值，可以自己设置，在创建表或者创建索引时指定。</p><ul><li><p><strong>主键设计原则</strong></p><ul><li>满足业务需求的情况下，尽量降低主键的长度。</li><li>插入数据时，尽量选择顺序插入，选择使用<code>AUTO_INCREMENT</code>自增主键。</li><li>尽量不要使用<code>UUID</code>做主键或者是其他自然主键，如身份证号。</li><li>业务操作时，避免对主键的修改。</li></ul></li></ul><h4 id="3-order-by优化"><a href="#3-order-by优化" class="headerlink" title="3. order by优化"></a>3. <code>order by</code>优化</h4><ul><li><p><strong><code>order by</code>优化原则</strong></p><ul><li>根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则</li><li>尽量使用覆盖索引</li><li>多字段排序，一个升序一个降序，此时需要注意联合索引在创建时的规则（ASC&#x2F;DESC）</li><li>如果不可避免的出现<code>filesort</code>，大数据量排序时，可以适当增大排序缓冲区大小<code>sort_buffer_size</code>(默认256k)</li></ul></li></ul><h4 id="4-group-by优化"><a href="#4-group-by优化" class="headerlink" title="4. group by优化"></a>4. <code>group by</code>优化</h4><ul><li>在分组操作时，可以通过索引来提高效率</li><li>分组操作时，索引的使用也是满足最左前缀法则的</li></ul><h4 id="5-limit优化"><a href="#5-limit优化" class="headerlink" title="5. limit优化"></a>5. <code>limit</code>优化</h4><ul><li><p>当数据量很大时，使用类似 <code>SELECT … FROM table ORDER BY col LIMIT offset, count;</code> 进行分页查询，随着 <code>offset</code> 增加，查询成本会急剧上升，造成响应变慢。</p></li><li><p>原因在于：MySQL 需要跳过 <code>offset</code> 行（文件排序或索引扫描），然后再返回 <code>count</code> 行，跳过的数据越多，开销越大。</p></li><li><p>优化思路：一般分页查询时，通过创建<strong>覆盖索引</strong>能够比较好的提高性能，可以通过覆盖索引加子查询形式进行优化</p></li></ul><h4 id="6-count优化"><a href="#6-count优化" class="headerlink" title="6. count优化"></a>6. <code>count</code>优化</h4><ul><li><code>MyISAM</code>引擎把一个表的总行数存在了磁盘上，因此执行<code>count(*)</code>的时候会直接返回这个数，效率很高</li><li><code>InnoDB</code>引擎就麻烦了，它执行<code>count(*)</code>的时候，需要把数据一行一行地从引擎里面读出来。然后累积计数</li></ul><p>**优化思路：**自己计数</p><ul><li><p><code>count</code>的几种用法</p><ul><li><p><code>count()</code>是一个聚合函数，对于返回的结果集，一行行地判断，如果<code>count</code>函数地参数不是<code>NULL</code>，累计值就加1，否则不加，最后返回累计值。</p></li><li><p>用法：<code>count(*)</code>、<code>count(主键)</code>、<code>count(字段)</code>、<code>count(1)</code></p></li><li><p><code>count(主键)</code></p><p><code>InnoDB</code>引擎会遍历整张表，把每一行的主键id值都取出来，返回给服务层。服务层拿到主键后，直接按行进行累加（主键不可能为<code>null</code>）</p></li><li><p><code>count(字段)</code></p><p>没有<code>not  null</code>约束：<code>InnoDB</code>引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，服务层判断是否为<code>null</code>，不为<code>null</code>，计数累加</p><p>有<code>not  null</code>约束：<code>InnoDB</code>引擎会遍历整张表把每一行的字段值都取出来，返回给服务层。直接按行进行累加</p></li><li><p><code>count(1)</code></p><p><code>InnoDB</code>引擎遍历整张表，但不取值。服务层对于返回的每一行，放一个数字“1”进去，直接按行进行累加</p></li><li><p><code>count(*)</code></p><p><code>InnoDB</code>引擎并不会把全部字段取出来，而是专门做了优化，不取值，服务层直接按行进行累加</p></li></ul></li></ul><p><strong>按照效率排序的话，<code>count(字段)</code>&lt;<code>count(主键)</code>&lt;<code>count(1)</code> ≈ <code>count(*)</code>，所以尽量使用<code>count(*)</code></strong></p><h4 id="7-update优化"><a href="#7-update优化" class="headerlink" title="7. update优化"></a>7. <code>update</code>优化</h4><ul><li>**优化思路：**避免表锁</li></ul><p><code>InnoDB</code>的行锁是针对索引加的锁，不是针对记录加的锁，并且该索引不能失效，否则会从行锁升级为表锁</p><h4 id="8-小结"><a href="#8-小结" class="headerlink" title="8. 小结"></a>8. 小结</h4><ul><li><p><strong>（1）插入数据</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span>：批量插入、手动控制事务、主键顺序插入</span><br><span class="line">大批量插入：load  data  <span class="keyword">local</span>  infile</span><br></pre></td></tr></table></figure></li><li><p><strong>（2）主键优化</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">主键长度尽量短、顺序插入AUTO_INCREMENT</span><br></pre></td></tr></table></figure></li><li><p><strong>（3）order  by优化</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> index：直接通过索引返回数据，性能高</span><br><span class="line"><span class="keyword">using</span> filesort：需要将返回的结果在排序缓冲区排序</span><br></pre></td></tr></table></figure></li><li><p><strong>（4）group  by优化</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">索引，多字段分组满足最左前缀法则</span><br></pre></td></tr></table></figure></li><li><p><strong>（5）limit优化</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">覆盖索引<span class="operator">+</span>子查询</span><br></pre></td></tr></table></figure></li><li><p><strong>（6）count优化</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">性能：<span class="built_in">count</span>(字段)<span class="operator">&lt;</span><span class="built_in">count</span>(主键id)<span class="operator">&lt;</span><span class="built_in">count</span>(<span class="number">1</span>)≈<span class="built_in">count</span>(<span class="operator">*</span>)</span><br></pre></td></tr></table></figure></li><li><p><strong>（7）update优化</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">尽量根据主键<span class="operator">/</span>索引字段进行数据更新，避免行锁升级为表锁</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> MySQL学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL学习-进阶篇(二)索引</title>
      <link href="/2025/04/28/MySQL%E5%AD%A6%E4%B9%A0/%E8%BF%9B%E9%98%B6(%E4%BA%8C)-%E7%B4%A2%E5%BC%95/"/>
      <url>/2025/04/28/MySQL%E5%AD%A6%E4%B9%A0/%E8%BF%9B%E9%98%B6(%E4%BA%8C)-%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>索引（index）是帮助MySQL高效获取数据的数据结构（有序）。</p><ul><li><strong>优缺点</strong></li></ul><table><thead><tr><th>优势</th><th>劣势</th></tr></thead><tbody><tr><td>提高数据检索的效率，降低数据库的IO成本</td><td>索引列也是要占用空间的</td></tr><tr><td>通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗</td><td>索引大大提高了查询效率，同时却也降低更新表的速度，如对表进行insert、update、delete时，效率降低</td></tr></tbody></table><h1 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h1><p>MySQL的索引是在存储引擎层实现的，不同的存储引擎有不同的结构，主要包含以下几种：</p><p><img src="/post_image/MySQL%E5%AD%A6%E4%B9%A0/%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84.png" alt="索引结构"></p><table><thead><tr><th>索引结构</th><th>描述</th></tr></thead><tbody><tr><td>B+Tree索引</td><td>最常见的索引类型，大部分引擎都支持B+树索引</td></tr><tr><td>Hash索引</td><td>底层数据结构是用哈希表实现的，只有精确匹配索引列的查询才有效，不支持范围查询</td></tr><tr><td>R-tree（空间索引）</td><td>空间索引是MyISAM引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少</td></tr><tr><td>Full-text（全文索引）</td><td>是一种通过建立倒排索引，快速匹配文档的方式。类似于Lucene，Solr，ES</td></tr></tbody></table><table><thead><tr><th>索引</th><th>InnoDB</th><th>MyISAM</th><th>Memory</th></tr></thead><tbody><tr><td>B+tree索引</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>Hash索引</td><td>不支持</td><td>不支持</td><td>支持</td></tr><tr><td>R-tree索引</td><td>不支持</td><td>支持</td><td>不支持</td></tr><tr><td>Full-text</td><td>5.6版本之后支持</td><td>支持</td><td>不支持</td></tr></tbody></table><h1 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h1><table><thead><tr><th>分类</th><th>含义</th><th>特点</th><th>关键字</th></tr></thead><tbody><tr><td>主键索引</td><td>针对于表中主键创建的索引</td><td>默认自动创建</td><td>PRIMARY</td></tr><tr><td>唯一索引</td><td>避免同一个表中某数据列的值重复</td><td>可以有多个</td><td>UNIQUE</td></tr><tr><td>常规索引</td><td>快速定位特定数据</td><td>可以有多个</td><td></td></tr><tr><td>全文索引</td><td>全文索引查找的是文本中的关键词，而不是比较索引中的值</td><td>可以有多个</td><td>FULLTEXT</td></tr></tbody></table><p>在InnoDB存储引擎中，根据索引的存储形式，可以分为以下两种：</p><table><thead><tr><th>分类</th><th>含义</th><th>特点</th></tr></thead><tbody><tr><td>聚集索引(Clustered Index)</td><td>将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据</td><td>必须有，而且只有一个</td></tr><tr><td>二级索引(Secondary Index)</td><td>将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键</td><td>可以存在多个</td></tr></tbody></table><ul><li>如果存在主键，主键索引就是聚集索引</li><li>如果不存在主键，将使用第一个唯一索引作为聚集索引</li><li>如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引</li></ul><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ol><li>以下SQL语句，哪个执行效率高？为什么？</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;Arm&#x27;</span>;</span><br><span class="line">备注：id为主键，name字段创建的有索引</span><br></pre></td></tr></table></figure><p>第一个执行效率更高，直接根据聚集索引便可以得到行数据</p><p>第二个二级索引需要得到<code>id</code>，再根据<code>id</code>查找到行数据，需要回表查询</p><ol start="2"><li>InnoDB主键索引的B+tree高度为多高呢？</li></ol><h1 id="索引语法"><a href="#索引语法" class="headerlink" title="索引语法"></a>索引语法</h1><ul><li>创建索引</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> [<span class="keyword">unique</span>][fulltext] index index_name <span class="keyword">on</span> table_name (index_clo_name,...);</span><br></pre></td></tr></table></figure><ul><li>查看索引</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> index <span class="keyword">from</span> table_name;</span><br></pre></td></tr></table></figure><ul><li>删除索引</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> index index_name om table_name;</span><br></pre></td></tr></table></figure><h1 id="SQL性能分析"><a href="#SQL性能分析" class="headerlink" title="SQL性能分析"></a>SQL性能分析</h1><ul><li><strong>SQL执行频率</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> status <span class="string">&#x27;Com_______&#x27;</span># <span class="number">7</span>个下划线</span><br><span class="line"># 可以查当前数据库的<span class="keyword">insert</span>、<span class="keyword">update</span>、<span class="keyword">delete</span>、<span class="keyword">select</span>的访问频次。</span><br></pre></td></tr></table></figure><p>根据查询的频次针对当前数据库是否执行优化。</p><ul><li><strong>慢查询日志</strong></li></ul><p>慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒）的所有SQL语句的日志。</p><p>MySQL的慢查询日志默认没有开启，需要在MySQL的配置文件（&#x2F;etc&#x2F;my.cnf）中配置如下信息：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line"># 启用慢查询日志</span><br><span class="line">slow_query_log             <span class="operator">=</span> <span class="keyword">ON</span></span><br><span class="line"></span><br><span class="line"># 日志文件路径</span><br><span class="line">slow_query_log_file        <span class="operator">=</span> <span class="operator">/</span>var<span class="operator">/</span>log<span class="operator">/</span>mysql<span class="operator">/</span>slow<span class="operator">-</span>query.log</span><br><span class="line"></span><br><span class="line"># 阈值（秒），执行时间 ≥ 该值才记录</span><br><span class="line">long_query_time            <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"># 记录未使用索引的查询（可选）</span><br><span class="line">log_queries_not_using_indexes <span class="operator">=</span> <span class="keyword">ON</span></span><br><span class="line"></span><br><span class="line"># 输出方式：FILE <span class="operator">/</span> <span class="keyword">TABLE</span> <span class="operator">/</span> <span class="keyword">BOTH</span></span><br><span class="line">log_output                 <span class="operator">=</span> FILE</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>修改后需 重启：<code>sudo systemctl restart mysqld</code></p><ul><li><strong>profile详情</strong></li></ul><p><code>show profiles</code>能够在做SQL优化时帮助我们了解时间都耗费到哪里去了。通过<code>have_profiling</code>参数，能够看到当前MySQL是否支持<code>profile</code>操作：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> @<span class="variable">@have_profiling</span>;</span><br></pre></td></tr></table></figure><p>查询<code>profiling</code>状态开启或关闭</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> @<span class="variable">@profiling</span>;</span><br></pre></td></tr></table></figure><p>默认<code>profiling</code>是关闭的，可以通过<code>set</code>语句在<code>session/global</code>级别开启<code>profiling</code>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> profiling <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>执行一系列的业务<code>SQL</code>的操作，然后通过如下指令查看指令的执行耗时：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 查看每一条<span class="keyword">SQL</span>的耗时基本情况</span><br><span class="line"><span class="keyword">show</span> profiles;</span><br><span class="line"></span><br><span class="line"># 查看指定query_id的<span class="keyword">SQL</span>语句各个阶段的耗时情况</span><br><span class="line"><span class="keyword">show</span> profile <span class="keyword">for</span> query query_id;</span><br><span class="line"></span><br><span class="line"># 查看指定query_id的<span class="keyword">SQL</span>语句cpu的使用情况</span><br><span class="line"><span class="keyword">show</span> profile cpu <span class="keyword">for</span> query query_id;</span><br></pre></td></tr></table></figure><ul><li><strong>explain执行计划</strong></li></ul><p><code>explain</code>或者<code>desc</code>命令获取<code>MySQL</code>如何执行<code>select</code>语句的信息，包括在<code>select</code>语句执行过程中表如何连接和连接的顺序。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 直接在<span class="keyword">select</span>语句之前加上关键字explain<span class="operator">/</span><span class="keyword">desc</span></span><br><span class="line">explain <span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表名 <span class="keyword">where</span> 条件;</span><br></pre></td></tr></table></figure><p><img src="/post_image/MySQL%E5%AD%A6%E4%B9%A0/explain%E6%89%A7%E8%A1%8C.png" alt="explain执行"></p><table><thead><tr><th>字段名</th><th>含义说明</th></tr></thead><tbody><tr><td><strong>id</strong></td><td>查询的序号，表示查询中执行的顺序或层级。值相同则自上到下，值越大表示越优先执行的子查询。</td></tr><tr><td><strong>select_type</strong></td><td>查询类型（如 SIMPLE、PRIMARY、UNION、SUBQUERY、DERIVED 等）。</td></tr><tr><td><strong>table</strong></td><td>当前这一行引用的数据表名。</td></tr><tr><td><strong>partitions</strong></td><td>MySQL 使用的分区（如有使用分区表）。</td></tr><tr><td><strong>type</strong></td><td>连接类型，表示访问表的方法，性能由好到差：<code>system</code>&gt;<code>null</code>&gt;<code>const</code> &gt; <code>eq_ref</code> &gt; <code>ref</code> &gt; <code>range</code> &gt; <code>index</code> &gt; <code>ALL</code>。</td></tr><tr><td><strong>possible_keys</strong></td><td>查询中可能使用的索引。</td></tr><tr><td><strong>key</strong></td><td>实际使用的索引（<code>NULL</code> 表示未使用索引）。</td></tr><tr><td><strong>key_len</strong></td><td>MySQL 实际使用的索引长度（字节）。</td></tr><tr><td><strong>ref</strong></td><td>哪个字段或常量被用于与 key 一起查找记录。</td></tr><tr><td><strong>rows</strong></td><td>MySQL 估计必须读取的行数。</td></tr><tr><td><strong>filtered</strong></td><td>该表中符合条件的记录比例（百分比）。</td></tr><tr><td><strong>Extra</strong></td><td>其他额外的信息，可能值很多。</td></tr></tbody></table><p>🔍 <code>select_type</code> 常见值说明：</p><table><thead><tr><th>值</th><th>含义说明</th></tr></thead><tbody><tr><td><code>SIMPLE</code></td><td>简单查询，没有子查询或 UNION。</td></tr><tr><td><code>PRIMARY</code></td><td>最外层的 SELECT 查询。</td></tr><tr><td><code>UNION</code></td><td>UNION 中的第二个或之后的查询。</td></tr><tr><td><code>SUBQUERY</code></td><td>在 SELECT 或 WHERE 中出现的子查询。</td></tr><tr><td><code>DERIVED</code></td><td>出现在 FROM 子句中的子查询。</td></tr></tbody></table><p>🔍 <code>type</code>（访问类型）优劣顺序</p><table><thead><tr><th>类型</th><th>说明</th></tr></thead><tbody><tr><td><code>const</code></td><td>表中最多只有一行匹配，速度最快。</td></tr><tr><td><code>eq_ref</code></td><td>对于每个来自前面的表的行，组合一个唯一索引。</td></tr><tr><td><code>ref</code></td><td>使用非唯一索引或前缀索引。</td></tr><tr><td><code>range</code></td><td>使用索引范围查找（如 <code>BETWEEN</code>、<code>&gt;</code>）。</td></tr><tr><td><code>index</code></td><td>扫描整个索引。</td></tr><tr><td><code>ALL</code></td><td>全表扫描（性能最差）。</td></tr></tbody></table><p>🔍 <code>Extra</code> 字段常见值：</p><table><thead><tr><th>值</th><th>含义说明</th></tr></thead><tbody><tr><td><code>Using index</code></td><td>使用了覆盖索引（索引中包含查询所需全部字段）。</td></tr><tr><td><code>Using where</code></td><td>使用了 WHERE 条件进行过滤。</td></tr><tr><td><code>Using filesort</code></td><td>MySQL 需要额外排序操作（可能性能较差）。</td></tr><tr><td><code>Using temporary</code></td><td>使用了临时表（通常在排序或分组时）。</td></tr><tr><td><code>Using index condition</code></td><td>使用了索引下推（Index Condition Pushdown）。</td></tr><tr><td><code>Using join buffer</code></td><td>使用了连接缓存（通常是嵌套循环连接）。</td></tr><tr><td><code>Impossible WHERE</code></td><td>WHERE 条件永远为 false，返回空结果。</td></tr></tbody></table><h1 id="索引使用"><a href="#索引使用" class="headerlink" title="索引使用"></a>索引使用</h1><ul><li><strong>最左前缀法则</strong></li></ul><p><strong>查询中使用索引时，必须从索引的最左开始，连续地使用字段</strong>，才能命中索引。如果跳跃了某一列，索引将部分失效（后面的字段索引失效）。</p><p>✅ 示例：创建联合索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_user <span class="keyword">ON</span> users (name, age, gender);</span><br></pre></td></tr></table></figure><table><thead><tr><th>查询条件</th><th>使用索引字段</th><th>是否命中索引</th><th>说明</th></tr></thead><tbody><tr><td><code>WHERE name = &#39;Tom&#39;</code></td><td>name</td><td>✅ 是</td><td>使用最左前缀</td></tr><tr><td><code>WHERE name = &#39;Tom&#39; AND age = 18</code></td><td>name, age</td><td>✅ 是</td><td>使用了连续字段</td></tr><tr><td><code>WHERE name = &#39;Tom&#39; AND age = 18 AND gender = &#39;M&#39;</code></td><td>name, age, gender</td><td>✅ 是</td><td>完全使用索引</td></tr><tr><td><code>WHERE age = 18</code></td><td>无</td><td>❌ 否</td><td>非最左字段不能单独使用索引</td></tr><tr><td><code>WHERE gender = &#39;F&#39;</code></td><td>无</td><td>❌ 否</td><td>非最左字段不能单独使用索引</td></tr><tr><td><code>WHERE name = &#39;Tom&#39; AND gender = &#39;F&#39;</code></td><td>name</td><td>✅ 部分</td><td>中间断了 age，gender 无法用索引</td></tr><tr><td><code>WHERE name = &#39;Tom&#39; AND age &gt; 18</code></td><td>name, age</td><td>✅ 是</td><td>范围查询不影响前面字段</td></tr><tr><td><code>WHERE name = &#39;Tom&#39; AND age &gt; 18 AND gender = &#39;F&#39;</code></td><td>name, age</td><td>✅ 部分</td><td>范围查询中断，gender 无法用索引</td></tr></tbody></table><p><strong>❗ 注意事项</strong></p><ul><li>✅ 最左字段必须出现，才能用索引。</li><li>❌ 中间字段缺失，会中断索引使用。</li><li>❌ 范围查询会终止后续字段的索引使用。</li><li>✅ 使用 <code>=</code>、<code>IN</code>、<code>BETWEEN</code> 可继续索引。</li><li>❌ 避免在索引字段上做运算，如 <code>LEFT(name, 1)</code>。</li></ul><p><strong>🔍 使用 EXPLAIN 查看是否命中索引</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;Tom&#x27;</span>;</span><br></pre></td></tr></table></figure><ul><li><strong>模糊查询</strong></li></ul><p>如果仅仅是尾部模糊匹配，索引不会失效。如果是头部模糊匹配，索引失效。</p><ul><li><strong>or连接的条件</strong></li></ul><p>用or分割开的条件，如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到。 </p><ul><li><strong>数据分布影响</strong></li></ul><p>如果MySQL评估使用索引比全表更慢，则不使用索引。</p><ul><li><strong>覆盖索引</strong></li></ul><p>尽量使用覆盖索引（查询使用了索引，并且需要返回的列，在该索引中已经全部能够找到）减少<code>select *</code>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> index <span class="keyword">condition</span>:查找使用了索引，但是需要回表查询数据</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">where</span>;<span class="keyword">using</span> index:查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询数据</span><br></pre></td></tr></table></figure><ul><li><strong>前缀索引</strong></li></ul><p>当字段类型为字符串(<code>varchar</code>,<code>text</code>等)时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘IO，影响查询效率。此时可以只将字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX index_name <span class="keyword">ON</span> table_name (column_name(prefix_length));</span><br></pre></td></tr></table></figure><p>🔸 如何选择前缀长度？</p><p>可以通过以下 SQL 分析区分度：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> <span class="keyword">LEFT</span>(email, <span class="number">5</span>)) <span class="keyword">FROM</span> users;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> <span class="keyword">LEFT</span>(email, <span class="number">10</span>)) <span class="keyword">FROM</span> users;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> <span class="keyword">LEFT</span>(email, <span class="number">15</span>)) <span class="keyword">FROM</span> users;</span><br></pre></td></tr></table></figure><p>目标：当前缀长度能区分大部分行时，就可选择该长度。</p><ul><li><strong>单列索引和联合索引</strong></li></ul><p>单列索引：即一个索引只包含单个列</p><p>联合索引：即一个索引包含了多个列</p><p>在业务场景中，如果存在<strong>多个查询条件</strong>，考虑针对于查询字段建立索引时，建议<strong>建立联合索引，而非单列索引</strong></p><p><strong>多条件联合查询时，MySQL优化器会评估哪个字段的索引效率更高，会选择该索引完成本次查询</strong></p><h1 id="索引设计原则"><a href="#索引设计原则" class="headerlink" title="索引设计原则"></a>索引设计原则</h1><p>索引是提升数据库查询性能的关键手段之一。合理的索引设计可以极大提高查询效率，减少 I&#x2F;O 成本。以下是 <strong>MySQL 索引设计的核心原则</strong></p><p>以下是 MySQL（及大多数关系型数据库）中进行索引设计时的<strong>详细原则与最佳实践</strong>，帮助你在保证查询性能的同时，兼顾写入效率和存储开销。建议将此笔记保存为 Markdown 以便查阅。</p><h4 id="1-明确使用场景"><a href="#1-明确使用场景" class="headerlink" title="1. 明确使用场景"></a>1. 明确使用场景</h4><ol><li><strong>查询驱动</strong><ul><li>先分析业务最常用的查询：<code>WHERE</code>、<code>JOIN</code>、<code>ORDER BY</code>、<code>GROUP BY</code>；</li><li>针对这些场景设计索引，避免盲目全表扫描。</li></ul></li><li><strong>读写比评估</strong><ul><li>事务写入多、更新频繁的表要慎用索引；</li><li>读多写少的表可以多加索引以优化查询。</li></ul></li></ol><hr><h4 id="2-合理选择索引列"><a href="#2-合理选择索引列" class="headerlink" title="2. 合理选择索引列"></a>2. 合理选择索引列</h4><ol><li><strong>高基数列优先</strong><ul><li>基数＝不同值的数量／总行数；</li><li>高基数（如身份证号、用户名）更容易区分行，可提高索引效率。</li></ul></li><li><strong>避免低基数列单独索引</strong><ul><li>如性别（只有 male&#x2F;female）不宜单独建索引；</li><li>可与其他高基数列组合为联合索引。</li></ul></li></ol><hr><h4 id="3-联合索引（复合索引）策略"><a href="#3-联合索引（复合索引）策略" class="headerlink" title="3. 联合索引（复合索引）策略"></a>3. 联合索引（复合索引）策略</h4><ol><li><strong>最左前缀法则</strong><ul><li>联合索引 <code>(A, B, C)</code> 只对查询中按顺序使用前缀的字段生效；</li><li>如 <code>WHERE A</code>、<code>WHERE A AND B</code>、<code>WHERE A AND B AND C</code> 都可命中，<code>WHERE B</code> 或跳过 B 的 <code>WHERE A AND C</code> 则只能部分命中。</li></ul></li><li><strong>列顺序设计</strong><ul><li><strong>过滤性（选择性）最高</strong> 的列放最左；</li><li>若多列选择性接近，将经常用于排序或分组的列放前面；</li><li>避免频繁变化的列放最左，以减少索引维护开销。</li></ul></li><li><strong>覆盖索引</strong><ul><li>如果索引包含查询所需的所有字段，就无需回表（“Using index”）；</li><li>能显著提高查询性能。</li></ul></li></ol><hr><h4 id="4-索引类型选用"><a href="#4-索引类型选用" class="headerlink" title="4. 索引类型选用"></a>4. 索引类型选用</h4><ol><li><strong>BTREE（默认）</strong><ul><li>适用于大多数等值查询、范围查询、排序。</li></ul></li><li><strong>HASH</strong>（Memory 引擎）<ul><li>只支持等值查询，无法用于范围扫描或排序；</li><li>内存型场景下可用。</li></ul></li><li><strong>FULLTEXT</strong><ul><li>文本搜索专用索引，适用于大段文本的关键字匹配；</li><li>配合 <code>MATCH … AGAINST</code>。</li></ul></li><li><strong>SPATIAL</strong><ul><li>地理空间索引（如 MyISAM、InnoDB 的 GIS）；</li><li>适用于地理坐标查询。</li></ul></li></ol><hr><h4 id="5-前缀索引"><a href="#5-前缀索引" class="headerlink" title="5. 前缀索引"></a>5. 前缀索引</h4><ol><li><strong>节约空间</strong><ul><li>对长字符串列（<code>VARCHAR(255)</code>、<code>TEXT</code>）只索引前 N 个字符，如 <code>email(20)</code>；</li><li>平衡区分度与存储，推荐前缀长度能覆盖 80%~90% 唯一性。</li></ul></li><li><strong>局限</strong><ul><li>不能用于覆盖索引和排序；</li><li>只能用于前缀匹配查询。</li></ul></li></ol><hr><h4 id="6-避免无效索引"><a href="#6-避免无效索引" class="headerlink" title="6. 避免无效索引"></a>6. 避免无效索引</h4><ol><li><strong>函数&#x2F;表达式列</strong><ul><li>如 <code>WHERE LEFT(name,3)=&#39;Tom&#39;</code> 会导致索引失效；</li><li>可考虑创建生成列（Generated Column）并为其建索引。</li></ul></li><li><strong>类型不匹配</strong><ul><li>查询常量类型与列类型应一致，避免隐式转换（如 <code>WHERE id=&#39;123&#39;</code> 对 <code>INT</code> 列）。</li></ul></li><li><strong>过多索引</strong><ul><li>每个索引都会增加写入、更新和删除的开销；</li><li>定期 <code>SHOW INDEX</code>、分析慢查询，删除长期未使用的索引。</li></ul></li></ol><hr><h4 id="7-索引维护与监控"><a href="#7-索引维护与监控" class="headerlink" title="7. 索引维护与监控"></a>7. 索引维护与监控</h4><ol><li><strong>定期分析</strong><ul><li>使用 <code>ANALYZE TABLE</code> 更新统计信息；</li><li>用 <code>EXPLAIN</code> 分析查询是否命中了索引。</li></ul></li><li><strong>滚动优化</strong><ul><li>大表批量改写时先删除索引，批量完成后再重建索引；</li><li>减少写入锁等待和 IO 压力。</li></ul></li><li><strong>慢查询日志</strong><ul><li>开启慢查询日志，找出未走索引或效率低下的 SQL；</li><li>根据日志结果优化索引。</li></ul></li></ol><hr><h4 id="8-实践总结"><a href="#8-实践总结" class="headerlink" title="8. 实践总结"></a>8. 实践总结</h4><ul><li><strong>以业务为导向</strong>：先看用例，再设计索引；</li><li><strong>最左前缀</strong>：联合索引务必遵循；</li><li><strong>覆盖与前缀</strong>：能覆盖就覆盖，能节省就前缀；</li><li><strong>权衡存储与性能</strong>：索引越多，查询越快，但写越慢；</li><li><strong>持续迭代</strong>：定期审视、调整索引方案。</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> MySQL学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL学习-进阶篇(一)存储引擎</title>
      <link href="/2025/04/27/MySQL%E5%AD%A6%E4%B9%A0/%E8%BF%9B%E9%98%B6(%E4%B8%80)-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
      <url>/2025/04/27/MySQL%E5%AD%A6%E4%B9%A0/%E8%BF%9B%E9%98%B6(%E4%B8%80)-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="MySQL体系结构"><a href="#MySQL体系结构" class="headerlink" title="MySQL体系结构"></a>MySQL体系结构</h1><ul><li>连接层</li></ul><p>最上层是一些客户端和链接服务，主要完成一些类似于连接处理、授权认证、及相关的安全方案。服务器也会为安全接入的每个客户端验证它所具有的操作权限。</p><ul><li>服务层</li></ul><p>第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化，部分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如过程、函数等。</p><ul><li>引擎层</li></ul><p>存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API和引擎进行通信。不同的存储引擎具有不同的功能，这样我们可以根据自己的需要，来选取合适的存储引擎。</p><ul><li>存储层</li></ul><p>主要是将数据存储在文件系统之上，并完成与存储引擎的交互。</p><h1 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h1><ul><li>介绍</li></ul><p>InnoDB是一种兼顾高可靠性和高性能的通用存储引擎，在MySQL5.5之后，InnoDB是默认的MySQL存储引擎。</p><ul><li>特点</li></ul><p>DML操作遵循ACID模型，支持事务；</p><p>行级锁，提高并发访问性能；</p><p>支持外键foreign key约束，保证数据的完整性和正确性</p><p><strong>存储引擎特点</strong></p><table><thead><tr><th>特点</th><th>InnoDB</th><th>MyISAM</th><th>Memory</th></tr></thead><tbody><tr><td>存储限制</td><td>64TB</td><td>有</td><td>有</td></tr><tr><td>事务安全</td><td><strong>支持</strong></td><td>-</td><td>-</td></tr><tr><td>锁机制</td><td><strong>行锁</strong></td><td>表锁</td><td>表锁</td></tr><tr><td>B+tree索引</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>Hash索引</td><td>-</td><td>-</td><td>支持</td></tr><tr><td>全文索引</td><td>支持（5.6版本之后）</td><td>支持</td><td>-</td></tr><tr><td>空间使用</td><td>高</td><td>低</td><td>N&#x2F;A</td></tr><tr><td>内存使用</td><td>高</td><td>低</td><td>中等</td></tr><tr><td>批量插入过度</td><td>低</td><td>高</td><td>高</td></tr><tr><td>支持外键</td><td><strong>支持</strong></td><td>-</td><td>-</td></tr></tbody></table><h1 id="存储引擎选择"><a href="#存储引擎选择" class="headerlink" title="存储引擎选择"></a>存储引擎选择</h1><ul><li>InnoDB：是MySQL的默认存储引擎，支持事务、外键。如果应用对事务的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多的更新、删除操作，那么InnoDB存储引擎是比较合适的选择。</li><li>MyISAM：如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不是很高，那么选择这个存储引擎是非常合适的。</li><li>MEMORY：将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。MEMORY的缺陷就是对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性。</li></ul>]]></content>
      
      
      <categories>
          
          <category> MySQL学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL学习-基础篇(五)事务</title>
      <link href="/2025/04/25/MySQL%E5%AD%A6%E4%B9%A0/%E5%9F%BA%E7%A1%80(%E4%BA%94)-%E4%BA%8B%E5%8A%A1/"/>
      <url>/2025/04/25/MySQL%E5%AD%A6%E4%B9%A0/%E5%9F%BA%E7%A1%80(%E4%BA%94)-%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p><strong>事务</strong>是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。</p><h1 id="事务四大特性"><a href="#事务四大特性" class="headerlink" title="事务四大特性"></a><strong>事务四大特性</strong></h1><ul><li>原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。</li><li>一致性（Consistency）：事务完成时，必须使所有的数据保持一致状态。</li><li>隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。</li><li>持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。</li></ul><h1 id="并发事务问题"><a href="#并发事务问题" class="headerlink" title="并发事务问题"></a>并发事务问题</h1><table><thead><tr><th>问题</th><th>描述</th></tr></thead><tbody><tr><td>脏读</td><td>一个事务读到另一个事务还没有提交的数据</td></tr><tr><td>不可重复读</td><td>一个事务先后读取同一条记录，但两次读取的数据不同，称之为不可重复读</td></tr><tr><td>幻读</td><td>一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据已经存在，好像出现了”幻影“</td></tr></tbody></table><h1 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h1><table><thead><tr><th align="center">隔离级别</th><th align="center">脏读</th><th align="center">不可重复读</th><th align="center">幻读</th></tr></thead><tbody><tr><td align="center">Read uncommitted</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">Read committed</td><td align="center">×</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">Repeatable Read（默认）</td><td align="center">×</td><td align="center">×</td><td align="center">√</td></tr><tr><td align="center">Serializable</td><td align="center">×</td><td align="center">×</td><td align="center">×</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> MySQL学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL学习-基础篇(四)多表查询</title>
      <link href="/2025/04/22/MySQL%E5%AD%A6%E4%B9%A0/%E5%9F%BA%E7%A1%80(%E5%9B%9B)-%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/"/>
      <url>/2025/04/22/MySQL%E5%AD%A6%E4%B9%A0/%E5%9F%BA%E7%A1%80(%E5%9B%9B)-%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ul><li>概述：指从多张表中查询数据</li><li>笛卡尔积：笛卡尔乘积是指在数学中，两个集合A集合和B集合的所有组合情况。（在多表查询时，需要消除无效的笛卡尔积）</li></ul><h1 id="多表查询分类"><a href="#多表查询分类" class="headerlink" title="多表查询分类"></a>多表查询分类</h1><h2 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h2><h3 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h3><p>内连接：相当于查询A、B交集部分数据</p><ul><li>隐式内连接</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表<span class="number">1</span>,表<span class="number">2</span> <span class="keyword">where</span> 条件</span><br></pre></td></tr></table></figure><ul><li>显式内连接</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表<span class="number">1</span> [<span class="keyword">inner</span>] <span class="keyword">join</span> 表<span class="number">2</span> <span class="keyword">on</span> 连接条件...;</span><br></pre></td></tr></table></figure><h3 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h3><p>左外连接：查询左表所有数据，以及两张表交集部分数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表<span class="number">1</span> <span class="keyword">left</span> [<span class="keyword">outer</span>] <span class="keyword">join</span> 表<span class="number">2</span> <span class="keyword">on</span> 条件...;</span><br></pre></td></tr></table></figure><p>右外连接：查询右表所有数据，以及两张表交集部分数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表<span class="number">1</span> <span class="keyword">right</span> [<span class="keyword">outer</span>] <span class="keyword">join</span> 表<span class="number">2</span> <span class="keyword">on</span> 条件...;</span><br></pre></td></tr></table></figure><h3 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h3><p>自连接：当前表与自身的连接查询，自连接必须使用表别名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表A 别名A <span class="keyword">join</span> 表A 别名B <span class="keyword">on</span> 条件...;</span><br></pre></td></tr></table></figure><p>**注意：**自连接可以是内连接，也可以是外连接</p><h2 id="联合查询"><a href="#联合查询" class="headerlink" title="联合查询"></a>联合查询</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表A...</span><br><span class="line"><span class="keyword">union</span> [<span class="keyword">all</span>]</span><br><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表B...;</span><br></pre></td></tr></table></figure><h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><p>**概念：**SQL语句中嵌套select语句，称为嵌套查询，又称子查询。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">where</span> column1 <span class="operator">=</span> (<span class="keyword">select</span> column1 <span class="keyword">from</span> t2);</span><br></pre></td></tr></table></figure><p><strong>子查询外部的语句可以是insert&#x2F;update&#x2F;delete&#x2F;select的任何一个。</strong></p>]]></content>
      
      
      <categories>
          
          <category> MySQL学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL学习-基础篇(三)约束</title>
      <link href="/2025/04/19/MySQL%E5%AD%A6%E4%B9%A0/%E5%9F%BA%E7%A1%80(%E4%B8%89)-%E7%BA%A6%E6%9D%9F/"/>
      <url>/2025/04/19/MySQL%E5%AD%A6%E4%B9%A0/%E5%9F%BA%E7%A1%80(%E4%B8%89)-%E7%BA%A6%E6%9D%9F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><strong>约束是作用与表中字段上的规则，用于限制存储在表中的数据。</strong></p><table><thead><tr><th>约束</th><th>描述</th><th>关键字</th></tr></thead><tbody><tr><td>非空约束</td><td>限制该字段的数据不能为null</td><td>not null</td></tr><tr><td>唯一约束</td><td>保证该字段的所有数据都是唯一、不重复的</td><td>unique</td></tr><tr><td>主键约束</td><td>主键是一行数据的唯一标识，要求非空且唯一</td><td>primary key</td></tr><tr><td>默认约束</td><td>保存数据时，如果未指定该字段的值，则采用默认值</td><td>default</td></tr><tr><td>检查约束</td><td>保证字段值满足某一个条件</td><td>check</td></tr><tr><td>外键约束</td><td>用来让两张表的数据之间建立连接，保证数据的一致性和完整性</td><td>foreign key</td></tr></tbody></table><p>**注意：**约束是作用于表中字段上的，可以在创建表&#x2F;修改表的时候添加约束。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL学习-基础篇(二)函数</title>
      <link href="/2025/04/17/MySQL%E5%AD%A6%E4%B9%A0/%E5%9F%BA%E7%A1%80(%E4%BA%8C)-%E5%87%BD%E6%95%B0/"/>
      <url>/2025/04/17/MySQL%E5%AD%A6%E4%B9%A0/%E5%9F%BA%E7%A1%80(%E4%BA%8C)-%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h1><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>concat(s1,s2,…sn)</td><td>字符串拼接，将s1，s2，……sn拼接成一个字符串</td></tr><tr><td>lower(str)</td><td>将字符串str全部转为小写</td></tr><tr><td>upper(str)</td><td>将字符串str全部转为大写</td></tr><tr><td>lpad(str,n,pad)</td><td>左填充，用字符串pad对str的左边进行填充，达到n个字符串长度</td></tr><tr><td>rpad(str,n,pad)</td><td>右填充，用字符串pad对str的右边进行填充，达到n个字符串长度</td></tr><tr><td>trim(str)</td><td>去掉字符串头部和尾部的空格</td></tr><tr><td>substring(str,start,len)</td><td>返回从字符串str从start位置起的len个长度的字符串</td></tr></tbody></table><h1 id="数值函数"><a href="#数值函数" class="headerlink" title="数值函数"></a>数值函数</h1><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>ceil(x)</td><td>向上取整</td></tr><tr><td>floor(x)</td><td>向下取整</td></tr><tr><td>mod(x,y)</td><td>返回x&#x2F;y的模</td></tr><tr><td>rand()</td><td>返回0~1内的随机数</td></tr><tr><td>round(x,y)</td><td>求参数x的四舍五入的值，保留y位小数</td></tr></tbody></table><h1 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h1><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>curdate()</td><td>返回当前日期</td></tr><tr><td>curtime()</td><td>返回当前时间</td></tr><tr><td>now()</td><td>返回当前日期和时间</td></tr><tr><td>year(date)</td><td>获取指定date的年份</td></tr><tr><td>month(date)</td><td>获取指定date的月份</td></tr><tr><td>day(date)</td><td>获取指定date的日期</td></tr><tr><td>date_add(date,interval expr type)</td><td>返回一个日期&#x2F;时间值加上一个时间间隔expr后的时间值</td></tr><tr><td>datediff(date1,date2)</td><td>返回起始时间date1和结束时间date2之间的天数</td></tr></tbody></table><h1 id="流程函数"><a href="#流程函数" class="headerlink" title="流程函数"></a>流程函数</h1><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>if(value,t,f)</td><td>如果value为true，则返回t，否则返回f</td></tr><tr><td>ifnull(value1,value2)</td><td>如果value1不为空，返回value1，否则返回value2</td></tr><tr><td>case when [val1] then [res1] … else [default] end-</td><td>如果val1为true，返回res1，…否则返回default默认值</td></tr><tr><td>case [expr] when [val1] then [res1] … else [default] end</td><td>如果expr的值等于val1，返回res1，…否则返回default默认值</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> MySQL学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo + Butterfly 搭建博客教程（一）Hexo框架</title>
      <link href="/2025/04/15/Hexo%E6%90%AD%E5%BB%BAblog%E6%95%99%E7%A8%8B/hexo-build-tutorial-1/"/>
      <url>/2025/04/15/Hexo%E6%90%AD%E5%BB%BAblog%E6%95%99%E7%A8%8B/hexo-build-tutorial-1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="什么是Hexo？"><a href="#什么是Hexo？" class="headerlink" title="什么是Hexo？"></a>什么是Hexo？</h1><p><code>Hexo</code> 是一个快速、简洁且高效的博客框架。 <code>Hexo</code> 使用 <a href="https://daringfireball.net/projects/markdown/">Markdown</a>（或其他标记语言）解析文章，依赖于<code>node.js</code>，可以在几秒内便生成静态网页。最大的优势是其可以结合<a href="https://pages.github.com/">Github page</a>实现真正的0成本建站，搭建属于自己的Blog。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><p>安装 <code>Hexo</code> 相当简单，只需要先安装下列应用程序即可：</p><ul><li><a href="https://nodejs.org/zh-cn">Node.js</a>(Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本)</li><li><a href="https://git-scm.com/">Git</a></li><li>如果您的电脑中已经安装上述必备程序，那么恭喜您！ 你可以直接前往<strong>安装 Hexo</strong>步骤。</li></ul><p>如果您的电脑中尚未安装所需要的程序，请根据以下安装指示完成安装。</p><h2 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h2><ul><li>所用的电脑是Windows系统，故只介绍下Windows下的安装。</li><li>在官网下载<a href="https://git-scm.com/downloads/win">Git</a>，直接傻瓜式安装，一路next。</li><li>安装完成后，按下 Windows + R 打开运行，输入CMD并回车，打开命令提示符，输入<code>git -v</code></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git -v</span><br></pre></td></tr></table></figure><ul><li>可以顺利得到版本号即说明安装成功。</li><li>打开<code>git bash</code>配置<code>username</code>和<code>email</code>。</li></ul><h2 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h2><ul><li>前往<a href="https://nodejs.org/zh-cn/">Node.js</a>官网下载安装长期维护版。</li><li>安装完成后，在命令行窗口输入<code>node -v</code>和<code>npm -v</code>，正确得到版本号，则安装成功。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure><h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><p>终于到了安装<code>Hexo</code>了</p><ul><li>在命令行中输入如下命令</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><ul><li>查询版本</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo -v </span><br></pre></td></tr></table></figure><h2 id="Node-js版本限制"><a href="#Node-js版本限制" class="headerlink" title="Node.js版本限制"></a>Node.js版本限制</h2><p>下面给出版本Node.js版本和Hexo的对应，具体可查看<a href="https://hexo.io/zh-cn/docs/#Node-js-%E7%89%88%E6%9C%AC%E9%99%90%E5%88%B6">Hexo官方文档</a></p><table><thead><tr><th align="left">Hexo 版本</th><th align="left">最低版本 (Node.js 版本)</th><th align="left">最高版本 (Node.js 版本)</th></tr></thead><tbody><tr><td align="left">7.0+</td><td align="left">14.0.0</td><td align="left">latest</td></tr><tr><td align="left">6.2+</td><td align="left">12.13.0</td><td align="left">latest</td></tr><tr><td align="left">6.0+</td><td align="left">12.13.0</td><td align="left">18.5.0</td></tr><tr><td align="left">5.0+</td><td align="left">10.13.0</td><td align="left">12.0.0</td></tr><tr><td align="left">4.1 - 4.2</td><td align="left">8.10</td><td align="left">10.0.0</td></tr><tr><td align="left">4.0</td><td align="left">8.6</td><td align="left">8.10.0</td></tr><tr><td align="left">3.3 - 3.9</td><td align="left">6.9</td><td align="left">8.0.0</td></tr><tr><td align="left">3.2 - 3.3</td><td align="left">0.12</td><td align="left">未知</td></tr><tr><td align="left">3.0 - 3.1</td><td align="left">0.10 或 iojs</td><td align="left">未知</td></tr><tr><td align="left">0.0.1 - 2.8</td><td align="left">0.10</td><td align="left">未知</td></tr></tbody></table><h1 id="Hexo常见命令"><a href="#Hexo常见命令" class="headerlink" title="Hexo常见命令"></a>Hexo常见命令</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">hexo init [folder]：初始化新的 Hexo 项目</span><br><span class="line"></span><br><span class="line">hexo new [layout] &lt;title&gt;：创建新文章或页面</span><br><span class="line"></span><br><span class="line">hexo generate 或 hexo g：生成静态文件</span><br><span class="line"></span><br><span class="line">hexo server 或 hexo s：启动本地服务器进行预览</span><br><span class="line"></span><br><span class="line">hexo deploy 或 hexo d：部署网站到远程服务器</span><br><span class="line"></span><br><span class="line">hexo clean：清除缓存和已生成的静态文件</span><br><span class="line"></span><br><span class="line">hexo new draft &lt;title&gt;：创建草稿</span><br><span class="line"></span><br><span class="line">hexo server --draft：预览草稿</span><br><span class="line"></span><br><span class="line">hexo publish &lt;title&gt;：发布草稿</span><br></pre></td></tr></table></figure><p>更多以及详细的命令参数设置可以查阅官方<a href="https://hexo.io/docs/commands">Hexo命令文档</a></p><h1 id="建站和试运行"><a href="#建站和试运行" class="headerlink" title="建站和试运行"></a>建站和试运行</h1><h2 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h2><p>安装Hexo后，执行以下命令，Hexo会在指定文件夹下新建项目</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo init &lt;folder&gt;</span><br><span class="line">cd &lt;folder&gt;</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><p>初始化后，项目文件夹会如下所示：</p><p><img src="/post_image/Hexo%E6%90%AD%E5%BB%BAblog%E6%95%99%E7%A8%8B/hexo1.png"></p><ul><li><code>_config.yml</code>：网站的 <a href="https://hexo.io/zh-cn/docs/configuration">配置</a> 文件，可以在此配置大部分的参数。</li><li><code>scaffolds</code>：<a href="https://hexo.io/zh-cn/docs/writing#%E6%A8%A1%E7%89%88%EF%BC%88Scaffold%EF%BC%89">模版</a> 文件夹。 新建文章时，Hexo 会根据 scaffold 来创建文件。</li><li><code>source</code>：资源文件夹。 是存放用户资源的地方。 除 <code>_posts</code> 文件夹之外，开头命名为 <code>_</code> (下划线)的文件 &#x2F; 文件夹和隐藏的文件将会被忽略。 Markdown 和 HTML 文件会被解析并放到 <code>public</code> 文件夹，而其他文件会被拷贝过去。</li><li><code>themes</code>：<a href="https://hexo.io/zh-cn/docs/themes">主题</a> 文件夹。 Hexo 会根据主题来生成静态页面。</li></ul><h2 id="config-yml文件"><a href="#config-yml文件" class="headerlink" title="_config.yml文件"></a>_config.yml文件</h2><p>这个文件配置网站的一些信息，这里只介绍一些基本的配置。</p><table><thead><tr><th>设置</th><th>描述</th></tr></thead><tbody><tr><td><code>title</code></td><td>网站标题</td></tr><tr><td><code>subtitle</code></td><td>网站副标题</td></tr><tr><td><code>description</code></td><td>网站描述</td></tr><tr><td><code>keywords</code></td><td>网站的关键词。 支持多个关键词。</td></tr><tr><td><code>author</code></td><td>您的名字</td></tr><tr><td><code>language</code></td><td>网站使用的语言。 使用 <a href="https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes">2 个字母的 ISO-639-1 代码</a>，或 <a href="https://hexo.io/docs/internationalization">它的变体</a>。 默认为 <code>en</code>。</td></tr><tr><td><code>timezone</code></td><td>网站时区。 Hexo 默认使用您电脑的时区。 请参考 <a href="https://en.wikipedia.org/wiki/List_of_tz_database_time_zones">时区列表</a> 进行设置，如 <code>America/New_York</code>, <code>Japan</code>, 和 <code>UTC</code> 。 一般的，对于中国大陆地区可以使用 <code>Asia/Shanghai</code>。</td></tr></tbody></table><p>这个文件中可以配置的信息有限，一般都需要使用hexo的一些主题来搭建更好看强大的网站，比如<code>next</code>、<code>butterfly</code>主题，主要是修改主题配置文件。</p><p>具体配置详情参照<a href="https://hexo.io/zh-cn/docs/configuration">Hexo官方配置文档</a></p><h2 id="试运行"><a href="#试运行" class="headerlink" title="试运行"></a>试运行</h2><p>执行<code>hexo clean</code>,<code>hexo g</code>,<code>hexo s</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>执行成功后便可以在本地看到网站运行了，配置信息啥的都没有修改，后续可以按照自己的想法进行打造。</p><p><img src="/post_image/Hexo%E6%90%AD%E5%BB%BAblog%E6%95%99%E7%A8%8B/hexo2.png"></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote><p><a href="https://hexo.io/zh-cn/docs/">Hexo官方文档</a><br><a href="https://nickxu.me/2022/02/13/Hexo%20+%20Butterfly%20%E5%BB%BA%E7%AB%99%E6%8C%87%E5%8D%97%EF%BC%88%E4%B8%80%EF%BC%89Hexo-%E6%A1%86%E6%9E%B6/">Hexo + Butterfly 建站指南（一）Hexo 框架</a></p></blockquote><hr><p>下一篇将介绍如何部署到Github自己的站点上</p>]]></content>
      
      
      <categories>
          
          <category> Hexo + Butterfly 搭建博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Hexo-Butterfly-Theme </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL学习-基础篇(一)SQL</title>
      <link href="/2025/04/15/MySQL%E5%AD%A6%E4%B9%A0/%E5%9F%BA%E7%A1%80(%E4%B8%80)-SQL/"/>
      <url>/2025/04/15/MySQL%E5%AD%A6%E4%B9%A0/%E5%9F%BA%E7%A1%80(%E4%B8%80)-SQL/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="SQL分类"><a href="#SQL分类" class="headerlink" title="SQL分类"></a>SQL分类</h1><table><thead><tr><th>分类</th><th>全称</th><th align="left">说明</th></tr></thead><tbody><tr><td>DDL</td><td>Data Definition Language</td><td align="left">数据定义语言，定义数据库对象（数据库，表，字段）</td></tr><tr><td>DML</td><td>Data Manipulation Language</td><td align="left">数据操作语言，增删改</td></tr><tr><td>DQL</td><td>Data Query Language</td><td align="left">数据查询语言，查</td></tr><tr><td>DCL</td><td>Data Control Language</td><td align="left">数据控制语言，创建数据库用户、控制数据库访问权限</td></tr></tbody></table><h1 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h1><p><strong>注：[…]中为可选参数</strong></p><h2 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h2><ul><li>查询所有数据库</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> databases;</span><br></pre></td></tr></table></figure><ul><li>查询当前数据库</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> database();</span><br></pre></td></tr></table></figure><ul><li>创建</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> database [if <span class="keyword">not</span> <span class="keyword">exists</span>] 数据库名 [<span class="keyword">default</span> charset 字符集] [<span class="keyword">collate</span> 排序规则];</span><br></pre></td></tr></table></figure><ul><li>删除</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> database [if <span class="keyword">exists</span>] 数据库名;</span><br></pre></td></tr></table></figure><ul><li>使用</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">USE 数据库名；</span><br></pre></td></tr></table></figure><h2 id="表操作"><a href="#表操作" class="headerlink" title="表操作"></a>表操作</h2><ul><li>查询当前数据库所有表</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> tables;</span><br></pre></td></tr></table></figure><ul><li>查询表结构</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">desc</span> 表名;</span><br></pre></td></tr></table></figure><ul><li>查询指定表的建表语句</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">create table</span> 表名;</span><br></pre></td></tr></table></figure><ul><li>创建</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create table</span> 表名(</span><br><span class="line">字段<span class="number">1</span> 字段<span class="number">1</span>类型 [comment 字段<span class="number">1</span>注释],</span><br><span class="line">字段<span class="number">2</span> 字段<span class="number">2</span>类型 [comment 字段<span class="number">2</span>注释],</span><br><span class="line">字段<span class="number">3</span> 字段<span class="number">3</span>类型 [comment 字段<span class="number">3</span>注释],</span><br><span class="line">    ......</span><br><span class="line">字段n 字段n类型 [comment 字段n注释]</span><br><span class="line">) [comment 表注释];</span><br></pre></td></tr></table></figure><ul><li>添加字段</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter table</span> 表名 <span class="keyword">add</span> 字段名 类型（长度） [comment 注释] [约束];</span><br></pre></td></tr></table></figure><ul><li>修改数据类型</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter table</span> 表名 modify 字段名 新数据类型（长度）</span><br></pre></td></tr></table></figure><ul><li>修改字段名和字段类型</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter table</span> 表名 change 旧字段名 新字段名 类型（长度） [comment 注释] [约束]; </span><br></pre></td></tr></table></figure><ul><li>删除字段</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter table</span> 表名 <span class="keyword">drop</span> 字段名;</span><br></pre></td></tr></table></figure><ul><li>修改表名</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter table</span> 表名 rename <span class="keyword">to</span> 新表名</span><br></pre></td></tr></table></figure><ul><li>删除表</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> [if <span class="keyword">exists</span>] 表名</span><br></pre></td></tr></table></figure><ul><li>删除指定表，并重新创建该表</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">truncate</span> <span class="keyword">table</span> 表名</span><br></pre></td></tr></table></figure><h1 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h1><h2 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h2><ul><li>给指定字段添加数据</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert into</span> 表名(字段名<span class="number">1</span>,字段名<span class="number">2</span>,...) <span class="keyword">values</span>(值<span class="number">1</span>,值<span class="number">2</span>,...);</span><br></pre></td></tr></table></figure><ul><li>给全部字段添加数据</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert into</span> 表名 <span class="keyword">values</span>(值<span class="number">1</span>,值<span class="number">2</span>,...);</span><br></pre></td></tr></table></figure><ul><li>批量添加数据</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert into</span> 表名(字段名<span class="number">1</span>,字段名<span class="number">2</span>,...) <span class="keyword">values</span>(值<span class="number">1</span>,值<span class="number">2</span>,...),(值<span class="number">1</span>,值<span class="number">2</span>,...),(值<span class="number">1</span>,值<span class="number">2</span>,...);</span><br><span class="line"><span class="keyword">insert into</span> 表名 <span class="keyword">values</span>(值<span class="number">1</span>,值<span class="number">2</span>,...),(值<span class="number">1</span>,值<span class="number">2</span>,...),(值<span class="number">1</span>,值<span class="number">2</span>,...);</span><br></pre></td></tr></table></figure><h2 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> 表名 <span class="keyword">set</span> 字段名<span class="number">1</span> <span class="operator">=</span> 值<span class="number">1</span>,字段名<span class="number">2</span> <span class="operator">=</span> 值<span class="number">2</span>,......[<span class="keyword">where</span> 条件]</span><br></pre></td></tr></table></figure><h2 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> 表名 [<span class="keyword">where</span> 条件]</span><br></pre></td></tr></table></figure><h1 id="DQL"><a href="#DQL" class="headerlink" title="DQL"></a>DQL</h1><h2 id="基本查询"><a href="#基本查询" class="headerlink" title="基本查询"></a>基本查询</h2><ul><li>查询多个字段</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段<span class="number">1</span>,字段<span class="number">2</span>,字段<span class="number">3.</span>..<span class="keyword">from</span> 表名;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表名;</span><br></pre></td></tr></table></figure><ul><li>设置别名</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段<span class="number">1</span> [<span class="keyword">as</span> 别名<span class="number">1</span>],字段<span class="number">2</span> [<span class="keyword">as</span> 别名<span class="number">2</span>] ... <span class="keyword">from</span> 表名;</span><br></pre></td></tr></table></figure><ul><li>去除重复记录</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> 字段列表 </span><br></pre></td></tr></table></figure><h2 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表名 <span class="keyword">where</span> 条件列表</span><br></pre></td></tr></table></figure><h2 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h2><ul><li>将一列数据作为一个整体，进行纵向计算。</li><li>常见聚合函数</li></ul><table><thead><tr><th align="center">函数</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">count</td><td align="center">统计数量</td></tr><tr><td align="center">max</td><td align="center">最大值</td></tr><tr><td align="center">min</td><td align="center">最小值</td></tr><tr><td align="center">avg</td><td align="center">平均值</td></tr><tr><td align="center">sum</td><td align="center">求和</td></tr></tbody></table><p><strong>注意</strong>：所有的null不参与聚合函数计算</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 聚合函数(字段列表) <span class="keyword">from</span> 表名;</span><br></pre></td></tr></table></figure><h2 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表名 [<span class="keyword">where</span> 条件] <span class="keyword">group</span> <span class="keyword">by</span> 分组字段名 [<span class="keyword">having</span> 分组后过滤条件]</span><br></pre></td></tr></table></figure><p><strong>where和having区别</strong></p><ul><li>执行时机不同：where是分组之前进行过滤，不满足where条件，不参与分组；而having是分组之后对结果进行过滤。</li><li>判断条件不同：where不能对聚合函数进行判断，而having可以。</li></ul><p><strong>注意</strong></p><ul><li>执行顺序：where&gt;聚合函数&gt;having。</li><li>分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义。</li></ul><h2 id="排序查询"><a href="#排序查询" class="headerlink" title="排序查询"></a>排序查询</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表名 <span class="keyword">order</span> <span class="keyword">by</span> 字段<span class="number">1</span> 排序方式<span class="number">1</span>,字段<span class="number">2</span> 排序方式<span class="number">2</span>;</span><br></pre></td></tr></table></figure><p><strong>排序方式</strong></p><ul><li>ASC：升序(默认值)</li><li>DESC：降序</li></ul><p>**注意：**如果是多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序。</p><h2 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表名 limit 起始索引,查询记录数;</span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><ul><li>起始索引从0开始，起始索引 &#x3D; （查询页码-1） * 每页显示记录数。</li><li>分页查询是数据库的方言，不同的数据库有不同的实现，MySQL中是limit。</li><li>如果查询的是第一页数据，起始索引可以省略，直接简写为limit 10。</li></ul><h2 id="DCL"><a href="#DCL" class="headerlink" title="DCL"></a>DCL</h2><h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><ul><li>查询用户</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">use mysql;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure><ul><li>创建用户</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;密码&#x27;</span>;</span><br></pre></td></tr></table></figure><ul><li>修改用户密码</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">user</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span> identified <span class="keyword">with</span> mysql_native_password <span class="keyword">by</span> <span class="string">&#x27;新密码&#x27;</span>;</span><br></pre></td></tr></table></figure><ul><li>删除用户</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">user</span><span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span>;</span><br></pre></td></tr></table></figure><h2 id="权限控制"><a href="#权限控制" class="headerlink" title="权限控制"></a>权限控制</h2><table><thead><tr><th>权限</th><th>说明</th></tr></thead><tbody><tr><td>all,all privileges</td><td>所有权限</td></tr><tr><td>select</td><td>查询权限</td></tr><tr><td>insert</td><td>插入权限</td></tr><tr><td>update</td><td>修改权限</td></tr><tr><td>delete</td><td>删除权限</td></tr><tr><td>alter</td><td>修改表</td></tr><tr><td>drop</td><td>删除数据库&#x2F;表&#x2F;视图</td></tr><tr><td>create</td><td>创建数据库&#x2F;表</td></tr></tbody></table><ul><li>查询权限</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> grants <span class="keyword">for</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span>;</span><br></pre></td></tr></table></figure><ul><li>授予权限</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span> 权限列表 <span class="keyword">on</span> 数据库名.表名 <span class="keyword">to</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span>;</span><br></pre></td></tr></table></figure><ul><li>撤销权限</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">revoke</span> 权限列表 <span class="keyword">on</span> 数据库名.表名 <span class="keyword">from</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MySQL学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>about</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>links</title>
      <link href="/links/index.html"/>
      <url>/links/index.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>music</title>
      <link href="/music/index.html"/>
      <url>/music/index.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>movies</title>
      <link href="/movies/index.html"/>
      <url>/movies/index.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
    </entry>
    
    
  
</search>
